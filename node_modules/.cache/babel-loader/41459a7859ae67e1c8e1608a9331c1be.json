{"ast":null,"code":"'use strict'; // Adapted from ReactART:\n// https://github.com/reactjs/react-art\n\nvar React = require('react');\n\nvar ReactMultiChild = require('react-dom/lib/ReactMultiChild');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\n\nvar ContainerMixin = Object.assign({}, ReactMultiChild.Mixin, {\n  /**\n   * Moves a child component to the supplied index.\n   *\n   * @param {ReactComponent} child Component to move.\n   * @param {number} toIndex Destination index of the element.\n   * @protected\n   */\n  moveChild: function (child, afterNode, toIndex, lastIndex) {\n    var childNode = child._mountImage;\n    var mostRecentlyPlacedChild = this._mostRecentlyPlacedChild;\n\n    if (mostRecentlyPlacedChild == null) {\n      // I'm supposed to be first.\n      if (childNode.previousSibling) {\n        if (this.node.firstChild) {\n          childNode.injectBefore(this.node.firstChild);\n        } else {\n          childNode.inject(this.node);\n        }\n      }\n    } else {\n      // I'm supposed to be after the previous one.\n      if (mostRecentlyPlacedChild.nextSibling !== childNode) {\n        if (mostRecentlyPlacedChild.nextSibling) {\n          childNode.injectBefore(mostRecentlyPlacedChild.nextSibling);\n        } else {\n          childNode.inject(this.node);\n        }\n      }\n    }\n\n    this._mostRecentlyPlacedChild = childNode;\n  },\n\n  /**\n   * Creates a child component.\n   *\n   * @param {ReactComponent} child Component to create.\n   * @param {object} childNode ART node to insert.\n   * @protected\n   */\n  createChild: function (child, afterNode, childNode) {\n    child._mountImage = childNode;\n    var mostRecentlyPlacedChild = this._mostRecentlyPlacedChild;\n\n    if (mostRecentlyPlacedChild == null) {\n      // I'm supposed to be first.\n      if (this.node.firstChild) {\n        childNode.injectBefore(this.node.firstChild);\n      } else {\n        childNode.inject(this.node);\n      }\n    } else {\n      // I'm supposed to be after the previous one.\n      if (mostRecentlyPlacedChild.nextSibling) {\n        childNode.injectBefore(mostRecentlyPlacedChild.nextSibling);\n      } else {\n        childNode.inject(this.node);\n      }\n    }\n\n    this._mostRecentlyPlacedChild = childNode;\n  },\n\n  /**\n   * Removes a child component.\n   *\n   * @param {ReactComponent} child Child to remove.\n   * @protected\n   */\n  removeChild: function (child) {\n    child._mountImage.remove();\n\n    child._mountImage = null;\n    this.node.invalidateLayout();\n  },\n  updateChildrenAtRoot: function (nextChildren, transaction) {\n    this.updateChildren(nextChildren, transaction, emptyObject);\n  },\n  mountAndInjectChildrenAtRoot: function (children, transaction) {\n    this.mountAndInjectChildren(children, transaction, emptyObject);\n  },\n\n  /**\n   * Override to bypass batch updating because it is not necessary.\n   *\n   * @param {?object} nextChildren.\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   * @override {ReactMultiChild.Mixin.updateChildren}\n   */\n  updateChildren: function (nextChildren, transaction, context) {\n    this._mostRecentlyPlacedChild = null;\n\n    this._updateChildren(nextChildren, transaction, context);\n  },\n  // Shorthands\n  mountAndInjectChildren: function (children, transaction, context) {\n    var mountedImages = this.mountChildren(children, transaction, context); // Each mount image corresponds to one of the flattened children\n\n    var i = 0;\n\n    for (var key in this._renderedChildren) {\n      if (this._renderedChildren.hasOwnProperty(key)) {\n        var child = this._renderedChildren[key];\n        child._mountImage = mountedImages[i];\n        mountedImages[i].inject(this.node);\n        i++;\n      }\n    }\n  },\n  getHostNode: function () {\n    return this.node;\n  },\n  getNativeNode: function () {\n    return this.node;\n  }\n});\nmodule.exports = ContainerMixin;","map":{"version":3,"sources":["C:/Users/sonwonjae/react/react-tutorial/canvas-example/node_modules/react-canvas/lib/ContainerMixin.js"],"names":["React","require","ReactMultiChild","emptyObject","ContainerMixin","Object","assign","Mixin","moveChild","child","afterNode","toIndex","lastIndex","childNode","_mountImage","mostRecentlyPlacedChild","_mostRecentlyPlacedChild","previousSibling","node","firstChild","injectBefore","inject","nextSibling","createChild","removeChild","remove","invalidateLayout","updateChildrenAtRoot","nextChildren","transaction","updateChildren","mountAndInjectChildrenAtRoot","children","mountAndInjectChildren","context","_updateChildren","mountedImages","mountChildren","i","key","_renderedChildren","hasOwnProperty","getHostNode","getNativeNode","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Adapted from ReactART:\n// https://github.com/reactjs/react-art\n\nvar React = require('react');\nvar ReactMultiChild = require('react-dom/lib/ReactMultiChild');\nvar emptyObject = require('fbjs/lib/emptyObject');\n\nvar ContainerMixin = Object.assign({}, ReactMultiChild.Mixin, {\n\n  /**\n   * Moves a child component to the supplied index.\n   *\n   * @param {ReactComponent} child Component to move.\n   * @param {number} toIndex Destination index of the element.\n   * @protected\n   */\n  moveChild: function(child, afterNode, toIndex, lastIndex) {\n    var childNode = child._mountImage;\n    var mostRecentlyPlacedChild = this._mostRecentlyPlacedChild;\n    if (mostRecentlyPlacedChild == null) {\n      // I'm supposed to be first.\n      if (childNode.previousSibling) {\n        if (this.node.firstChild) {\n          childNode.injectBefore(this.node.firstChild);\n        } else {\n          childNode.inject(this.node);\n        }\n      }\n    } else {\n      // I'm supposed to be after the previous one.\n      if (mostRecentlyPlacedChild.nextSibling !== childNode) {\n        if (mostRecentlyPlacedChild.nextSibling) {\n          childNode.injectBefore(mostRecentlyPlacedChild.nextSibling);\n        } else {\n          childNode.inject(this.node);\n        }\n      }\n    }\n    this._mostRecentlyPlacedChild = childNode;\n  },\n\n  /**\n   * Creates a child component.\n   *\n   * @param {ReactComponent} child Component to create.\n   * @param {object} childNode ART node to insert.\n   * @protected\n   */\n  createChild: function(child, afterNode, childNode) {\n    child._mountImage = childNode;\n    var mostRecentlyPlacedChild = this._mostRecentlyPlacedChild;\n    if (mostRecentlyPlacedChild == null) {\n      // I'm supposed to be first.\n      if (this.node.firstChild) {\n        childNode.injectBefore(this.node.firstChild);\n      } else {\n        childNode.inject(this.node);\n      }\n    } else {\n      // I'm supposed to be after the previous one.\n      if (mostRecentlyPlacedChild.nextSibling) {\n        childNode.injectBefore(mostRecentlyPlacedChild.nextSibling);\n      } else {\n        childNode.inject(this.node);\n      }\n    }\n    this._mostRecentlyPlacedChild = childNode;\n  },\n\n  /**\n   * Removes a child component.\n   *\n   * @param {ReactComponent} child Child to remove.\n   * @protected\n   */\n  removeChild: function(child) {\n    child._mountImage.remove();\n    child._mountImage = null;\n    this.node.invalidateLayout();\n  },\n\n  updateChildrenAtRoot: function(nextChildren, transaction) {\n    this.updateChildren(nextChildren, transaction, emptyObject);\n  },\n\n  mountAndInjectChildrenAtRoot: function(children, transaction) {\n    this.mountAndInjectChildren(children, transaction, emptyObject);\n  },\n\n  /**\n   * Override to bypass batch updating because it is not necessary.\n   *\n   * @param {?object} nextChildren.\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   * @override {ReactMultiChild.Mixin.updateChildren}\n   */\n  updateChildren: function(nextChildren, transaction, context) {\n    this._mostRecentlyPlacedChild = null;\n    this._updateChildren(nextChildren, transaction, context);\n  },\n\n  // Shorthands\n\n  mountAndInjectChildren: function(children, transaction, context) {\n    var mountedImages = this.mountChildren(\n      children,\n      transaction,\n      context\n    );\n\n    // Each mount image corresponds to one of the flattened children\n    var i = 0;\n    for (var key in this._renderedChildren) {\n      if (this._renderedChildren.hasOwnProperty(key)) {\n        var child = this._renderedChildren[key];\n        child._mountImage = mountedImages[i];\n        mountedImages[i].inject(this.node);\n        i++;\n      }\n    }\n  },\n  getHostNode: function () { return this.node },\n  getNativeNode: function () { return this.node },\n\n});\n\nmodule.exports = ContainerMixin;\n"]},"metadata":{},"sourceType":"script"}