{"ast":null,"code":"'use strict';\n\nvar FontFace = require('./FontFace');\n\nvar FontUtils = require('./FontUtils');\n\nvar LineBreaker = require('linebreak');\n\nvar canvas = document.createElement('canvas');\nvar ctx = canvas.getContext('2d');\nvar _cache = {};\nvar _zeroMetrics = {\n  width: 0,\n  height: 0,\n  lines: []\n};\n\nfunction getCacheKey(text, width, fontFace, fontSize, lineHeight) {\n  return text + width + fontFace.id + fontSize + lineHeight;\n}\n/**\n * Given a string of text, available width, and font return the measured width\n * and height.\n * @param {String} text The input string\n * @param {Number} width The available width\n * @param {FontFace} fontFace The FontFace to use\n * @param {Number} fontSize The font size in CSS pixels\n * @param {Number} lineHeight The line height in CSS pixels\n * @return {Object} Measured text size with `width` and `height` members.\n */\n\n\nmodule.exports = function measureText(text, width, fontFace, fontSize, lineHeight) {\n  var cacheKey = getCacheKey(text, width, fontFace, fontSize, lineHeight);\n  var cached = _cache[cacheKey];\n\n  if (cached) {\n    return cached;\n  } // Bail and return zero unless we're sure the font is ready.\n\n\n  if (!FontUtils.isFontLoaded(fontFace)) {\n    return _zeroMetrics;\n  }\n\n  var measuredSize = {};\n  var textMetrics;\n  var lastMeasuredWidth;\n  var words;\n  var tryLine;\n  var currentLine;\n  var breaker;\n  var bk;\n  var lastBreak;\n  ctx.font = fontFace.attributes.style + ' ' + fontFace.attributes.weight + ' ' + fontSize + 'px ' + fontFace.family;\n  textMetrics = ctx.measureText(text);\n  measuredSize.width = textMetrics.width;\n  measuredSize.height = lineHeight;\n  measuredSize.lines = [];\n\n  if (measuredSize.width <= width) {\n    // The entire text string fits.\n    measuredSize.lines.push({\n      width: measuredSize.width,\n      text: text\n    });\n  } else {\n    // Break into multiple lines.\n    measuredSize.width = width;\n    currentLine = '';\n    breaker = new LineBreaker(text);\n\n    while (bk = breaker.nextBreak()) {\n      var word = text.slice(lastBreak ? lastBreak.position : 0, bk.position);\n      tryLine = currentLine + word;\n      textMetrics = ctx.measureText(tryLine);\n\n      if (textMetrics.width > width || lastBreak && lastBreak.required) {\n        measuredSize.height += lineHeight;\n        measuredSize.lines.push({\n          width: lastMeasuredWidth,\n          text: currentLine.trim()\n        });\n        currentLine = word;\n        lastMeasuredWidth = ctx.measureText(currentLine.trim()).width;\n      } else {\n        currentLine = tryLine;\n        lastMeasuredWidth = textMetrics.width;\n      }\n\n      lastBreak = bk;\n    }\n\n    currentLine = currentLine.trim();\n\n    if (currentLine.length > 0) {\n      textMetrics = ctx.measureText(currentLine);\n      measuredSize.lines.push({\n        width: textMetrics,\n        text: currentLine\n      });\n    }\n  }\n\n  _cache[cacheKey] = measuredSize;\n  return measuredSize;\n};","map":{"version":3,"sources":["C:/Users/sonwonjae/react/react-tutorial/canvas-example/node_modules/react-canvas/lib/measureText.js"],"names":["FontFace","require","FontUtils","LineBreaker","canvas","document","createElement","ctx","getContext","_cache","_zeroMetrics","width","height","lines","getCacheKey","text","fontFace","fontSize","lineHeight","id","module","exports","measureText","cacheKey","cached","isFontLoaded","measuredSize","textMetrics","lastMeasuredWidth","words","tryLine","currentLine","breaker","bk","lastBreak","font","attributes","style","weight","family","push","nextBreak","word","slice","position","required","trim","length"],"mappings":"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","sourcesContent":["'use strict';\n\nvar FontFace = require('./FontFace');\nvar FontUtils = require('./FontUtils');\nvar LineBreaker = require('linebreak');\n\nvar canvas = document.createElement('canvas');\nvar ctx = canvas.getContext('2d');\n\nvar _cache = {};\nvar _zeroMetrics = {\n  width: 0,\n  height: 0,\n  lines: []\n};\n\nfunction getCacheKey (text, width, fontFace, fontSize, lineHeight) {\n  return text + width + fontFace.id + fontSize + lineHeight;\n}\n\n/**\n * Given a string of text, available width, and font return the measured width\n * and height.\n * @param {String} text The input string\n * @param {Number} width The available width\n * @param {FontFace} fontFace The FontFace to use\n * @param {Number} fontSize The font size in CSS pixels\n * @param {Number} lineHeight The line height in CSS pixels\n * @return {Object} Measured text size with `width` and `height` members.\n */\nmodule.exports = function measureText (text, width, fontFace, fontSize, lineHeight) {\n  var cacheKey = getCacheKey(text, width, fontFace, fontSize, lineHeight);\n  var cached = _cache[cacheKey];\n  if (cached) {\n    return cached;\n  }\n\n  // Bail and return zero unless we're sure the font is ready.\n  if (!FontUtils.isFontLoaded(fontFace)) {\n    return _zeroMetrics;\n  }\n\n  var measuredSize = {};\n  var textMetrics;\n  var lastMeasuredWidth;\n  var words;\n  var tryLine;\n  var currentLine;\n  var breaker;\n  var bk;\n  var lastBreak;\n\n  ctx.font = fontFace.attributes.style + ' ' + fontFace.attributes.weight + ' ' + fontSize + 'px ' + fontFace.family;\n  textMetrics = ctx.measureText(text);\n\n  measuredSize.width = textMetrics.width;\n  measuredSize.height = lineHeight;\n  measuredSize.lines = [];\n\n  if (measuredSize.width <= width) {\n    // The entire text string fits.\n    measuredSize.lines.push({width: measuredSize.width, text: text});\n  } else {\n    // Break into multiple lines.\n    measuredSize.width = width;\n    currentLine = '';\n    breaker = new LineBreaker(text);\n    \n    while (bk = breaker.nextBreak()) {\n      var word = text.slice(lastBreak ? lastBreak.position : 0, bk.position);\n      \n      tryLine = currentLine + word;\n      textMetrics = ctx.measureText(tryLine);\n      if (textMetrics.width > width || (lastBreak && lastBreak.required)) {\n        measuredSize.height += lineHeight;\n        measuredSize.lines.push({width: lastMeasuredWidth, text: currentLine.trim()});\n        currentLine = word;\n        lastMeasuredWidth = ctx.measureText(currentLine.trim()).width;\n      } else {\n        currentLine = tryLine;\n        lastMeasuredWidth = textMetrics.width;\n      }\n      \n      lastBreak = bk;\n    }\n    \n    currentLine = currentLine.trim();\n    if (currentLine.length > 0) {\n      textMetrics = ctx.measureText(currentLine);\n      measuredSize.lines.push({width: textMetrics, text: currentLine});\n    }\n  }\n\n  _cache[cacheKey] = measuredSize;\n\n  return measuredSize;\n};\n"]},"metadata":{},"sourceType":"script"}