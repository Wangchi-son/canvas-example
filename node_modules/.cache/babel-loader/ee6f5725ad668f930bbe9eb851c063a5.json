{"ast":null,"code":"'use strict';\n\nvar FrameUtils = require('./FrameUtils');\n\nvar DrawingUtils = require('./DrawingUtils');\n\nvar EventTypes = require('./EventTypes');\n\nfunction RenderLayer() {\n  this.children = [];\n  this.frame = FrameUtils.zero();\n}\n\nRenderLayer.prototype = {\n  /**\n   * Retrieve the root injection layer\n   *\n   * @return {RenderLayer}\n   */\n  getRootLayer: function () {\n    var root = this;\n\n    while (root.parentLayer) {\n      root = root.parentLayer;\n    }\n\n    return root;\n  },\n\n  /**\n   * RenderLayers are injected into a root owner layer whenever a Surface is\n   * mounted. This is the integration point with React internals.\n   *\n   * @param {RenderLayer} parentLayer\n   */\n  inject: function (parentLayer) {\n    if (this.parentLayer && this.parentLayer !== parentLayer) {\n      this.remove();\n    }\n\n    if (!this.parentLayer) {\n      parentLayer.addChild(this);\n    }\n  },\n\n  /**\n   * Inject a layer before a reference layer\n   *\n   * @param {RenderLayer} parentLayer\n   * @param {RenderLayer} referenceLayer\n   */\n  injectBefore: function (parentLayer, referenceLayer) {\n    // FIXME\n    this.inject(parentLayer);\n  },\n\n  /**\n   * Add a child to the render layer\n   *\n   * @param {RenderLayer} child\n   */\n  addChild: function (child) {\n    child.parentLayer = this;\n    this.children.push(child);\n  },\n\n  /**\n   * Remove a layer from it's parent layer\n   */\n  remove: function () {\n    if (this.parentLayer) {\n      this.parentLayer.children.splice(this.parentLayer.children.indexOf(this), 1);\n    }\n  },\n\n  /**\n   * Attach an event listener to a layer. Supported events are defined in\n   * lib/EventTypes.js\n   *\n   * @param {String} type\n   * @param {Function} callback\n   * @param {?Object} callbackScope\n   * @return {Function} invoke to unsubscribe the listener\n   */\n  subscribe: function (type, callback, callbackScope) {\n    // This is the integration point with React, called from LayerMixin.putEventListener().\n    // Enforce that only a single callbcak can be assigned per event type.\n    for (var eventType in EventTypes) {\n      if (EventTypes[eventType] === type) {\n        this[eventType] = callback;\n      }\n    } // Return a function that can be called to unsubscribe from the event.\n\n\n    return this.removeEventListener.bind(this, type, callback, callbackScope);\n  },\n\n  /**\n   * @param {String} type\n   * @param {Function} callback\n   * @param {?Object} callbackScope\n   */\n  addEventListener: function (type, callback, callbackScope) {\n    for (var eventType in EventTypes) {\n      if (EventTypes[eventType] === type) {\n        delete this[eventType];\n      }\n    }\n  },\n\n  /**\n   * @param {String} type\n   * @param {Function} callback\n   * @param {?Object} callbackScope\n   */\n  removeEventListener: function (type, callback, callbackScope) {\n    var listeners = this.eventListeners[type];\n    var listener;\n\n    if (listeners) {\n      for (var index = 0, len = listeners.length; index < len; index++) {\n        listener = listeners[index];\n\n        if (listener.callback === callback && listener.callbackScope === callbackScope) {\n          listeners.splice(index, 1);\n          break;\n        }\n      }\n    }\n  },\n\n  /**\n   * Translate a layer's frame\n   *\n   * @param {Number} x\n   * @param {Number} y\n   */\n  translate: function (x, y) {\n    if (this.frame) {\n      this.frame.x += x;\n      this.frame.y += y;\n    }\n\n    if (this.clipRect) {\n      this.clipRect.x += x;\n      this.clipRect.y += y;\n    }\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        child.translate(x, y);\n      });\n    }\n  },\n\n  /**\n   * Layers should call this method when they need to be redrawn. Note the\n   * difference here between `invalidateBackingStore`: updates that don't\n   * trigger layout should prefer `invalidateLayout`. For instance, an image\n   * component that is animating alpha level after the image loads would\n   * call `invalidateBackingStore` once after the image loads, and at each\n   * step in the animation would then call `invalidateRect`.\n   *\n   * @param {?Frame} frame Optional, if not passed the entire layer's frame\n   *   will be invalidated.\n   */\n  invalidateLayout: function () {\n    // Bubble all the way to the root layer.\n    this.getRootLayer().draw();\n  },\n\n  /**\n   * Layers should call this method when their backing <canvas> needs to be\n   * redrawn. For instance, an image component would call this once after the\n   * image loads.\n   */\n  invalidateBackingStore: function () {\n    if (this.backingStoreId) {\n      DrawingUtils.invalidateBackingStore(this.backingStoreId);\n    }\n\n    this.invalidateLayout();\n  },\n\n  /**\n   * Only the root owning layer should implement this function.\n   */\n  draw: function () {// Placeholer\n  }\n};\nmodule.exports = RenderLayer;","map":{"version":3,"sources":["C:/Users/sonwonjae/react/react-tutorial/canvas-example/node_modules/react-canvas/lib/RenderLayer.js"],"names":["FrameUtils","require","DrawingUtils","EventTypes","RenderLayer","children","frame","zero","prototype","getRootLayer","root","parentLayer","inject","remove","addChild","injectBefore","referenceLayer","child","push","splice","indexOf","subscribe","type","callback","callbackScope","eventType","removeEventListener","bind","addEventListener","listeners","eventListeners","listener","index","len","length","translate","x","y","clipRect","forEach","invalidateLayout","draw","invalidateBackingStore","backingStoreId","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar FrameUtils = require('./FrameUtils');\nvar DrawingUtils = require('./DrawingUtils');\nvar EventTypes = require('./EventTypes');\n\nfunction RenderLayer () {\n  this.children = [];\n  this.frame = FrameUtils.zero();\n}\n\nRenderLayer.prototype = {\n\n  /**\n   * Retrieve the root injection layer\n   *\n   * @return {RenderLayer}\n   */\n  getRootLayer: function () {\n    var root = this;\n    while (root.parentLayer) {\n      root = root.parentLayer;\n    }\n    return root;\n  },\n\n  /**\n   * RenderLayers are injected into a root owner layer whenever a Surface is\n   * mounted. This is the integration point with React internals.\n   *\n   * @param {RenderLayer} parentLayer\n   */\n  inject: function (parentLayer) {\n    if (this.parentLayer && this.parentLayer !== parentLayer) {\n      this.remove();\n    }\n    if (!this.parentLayer) {\n      parentLayer.addChild(this);\n    }\n  },\n\n  /**\n   * Inject a layer before a reference layer\n   *\n   * @param {RenderLayer} parentLayer\n   * @param {RenderLayer} referenceLayer\n   */\n  injectBefore: function (parentLayer, referenceLayer) {\n    // FIXME\n    this.inject(parentLayer);\n  },\n\n  /**\n   * Add a child to the render layer\n   *\n   * @param {RenderLayer} child\n   */\n  addChild: function (child) {\n    child.parentLayer = this;\n    this.children.push(child);\n  },\n\n  /**\n   * Remove a layer from it's parent layer\n   */\n  remove: function () {\n    if (this.parentLayer) {\n      this.parentLayer.children.splice(this.parentLayer.children.indexOf(this), 1);\n    }\n  },\n\n  /**\n   * Attach an event listener to a layer. Supported events are defined in\n   * lib/EventTypes.js\n   *\n   * @param {String} type\n   * @param {Function} callback\n   * @param {?Object} callbackScope\n   * @return {Function} invoke to unsubscribe the listener\n   */\n  subscribe: function (type, callback, callbackScope) {\n    // This is the integration point with React, called from LayerMixin.putEventListener().\n    // Enforce that only a single callbcak can be assigned per event type.\n    for (var eventType in EventTypes) {\n      if (EventTypes[eventType] === type) {\n        this[eventType] = callback;\n      }\n    }\n\n    // Return a function that can be called to unsubscribe from the event.\n    return this.removeEventListener.bind(this, type, callback, callbackScope);\n  },\n\n  /**\n   * @param {String} type\n   * @param {Function} callback\n   * @param {?Object} callbackScope\n   */\n  addEventListener: function (type, callback, callbackScope) {\n    for (var eventType in EventTypes) {\n      if (EventTypes[eventType] === type) {\n        delete this[eventType];\n      }\n    }\n  },\n\n  /**\n   * @param {String} type\n   * @param {Function} callback\n   * @param {?Object} callbackScope\n   */\n  removeEventListener: function (type, callback, callbackScope) {\n    var listeners = this.eventListeners[type];\n    var listener;\n    if (listeners) {\n      for (var index=0, len=listeners.length; index < len; index++) {\n        listener = listeners[index];\n        if (listener.callback === callback &&\n            listener.callbackScope === callbackScope) {\n          listeners.splice(index, 1);\n          break;\n        }\n      }\n    }\n  },\n\n  /**\n   * Translate a layer's frame\n   *\n   * @param {Number} x\n   * @param {Number} y\n   */\n  translate: function (x, y) {\n    if (this.frame) {\n      this.frame.x += x;\n      this.frame.y += y;\n    }\n\n    if (this.clipRect) {\n      this.clipRect.x += x;\n      this.clipRect.y += y;\n    }\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        child.translate(x, y);\n      });\n    }\n  },\n\n  /**\n   * Layers should call this method when they need to be redrawn. Note the\n   * difference here between `invalidateBackingStore`: updates that don't\n   * trigger layout should prefer `invalidateLayout`. For instance, an image\n   * component that is animating alpha level after the image loads would\n   * call `invalidateBackingStore` once after the image loads, and at each\n   * step in the animation would then call `invalidateRect`.\n   *\n   * @param {?Frame} frame Optional, if not passed the entire layer's frame\n   *   will be invalidated.\n   */\n  invalidateLayout: function () {\n    // Bubble all the way to the root layer.\n    this.getRootLayer().draw();\n  },\n\n  /**\n   * Layers should call this method when their backing <canvas> needs to be\n   * redrawn. For instance, an image component would call this once after the\n   * image loads.\n   */\n  invalidateBackingStore: function () {\n    if (this.backingStoreId) {\n      DrawingUtils.invalidateBackingStore(this.backingStoreId);\n    }\n    this.invalidateLayout();\n  },\n\n  /**\n   * Only the root owning layer should implement this function.\n   */\n  draw: function () {\n    // Placeholer\n  }\n\n};\n\nmodule.exports = RenderLayer;\n"]},"metadata":{},"sourceType":"script"}