{"ast":null,"code":"// https://github.com/facebook/css-layout\n\n/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\nvar computeLayout = function () {\n  function capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function getSpacing(node, type, suffix, location) {\n    var key = type + capitalizeFirst(location) + suffix;\n\n    if (key in node.style) {\n      return node.style[key];\n    }\n\n    key = type + suffix;\n\n    if (key in node.style) {\n      return node.style[key];\n    }\n\n    return 0;\n  }\n\n  function getPositiveSpacing(node, type, suffix, location) {\n    var key = type + capitalizeFirst(location) + suffix;\n\n    if (key in node.style && node.style[key] >= 0) {\n      return node.style[key];\n    }\n\n    key = type + suffix;\n\n    if (key in node.style && node.style[key] >= 0) {\n      return node.style[key];\n    }\n\n    return 0;\n  }\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  function getMargin(node, location) {\n    return getSpacing(node, 'margin', '', location);\n  }\n\n  function getPadding(node, location) {\n    return getPositiveSpacing(node, 'padding', '', location);\n  }\n\n  function getBorder(node, location) {\n    return getPositiveSpacing(node, 'border', 'Width', location);\n  }\n\n  function getPaddingAndBorder(node, location) {\n    return getPadding(node, location) + getBorder(node, location);\n  }\n\n  function getMarginAxis(node, axis) {\n    return getMargin(node, leading[axis]) + getMargin(node, trailing[axis]);\n  }\n\n  function getPaddingAndBorderAxis(node, axis) {\n    return getPaddingAndBorder(node, leading[axis]) + getPaddingAndBorder(node, trailing[axis]);\n  }\n\n  function getJustifyContent(node) {\n    if ('justifyContent' in node.style) {\n      return node.style.justifyContent;\n    }\n\n    return 'flex-start';\n  }\n\n  function getAlignItem(node, child) {\n    if ('alignSelf' in child.style) {\n      return child.style.alignSelf;\n    }\n\n    if ('alignItems' in node.style) {\n      return node.style.alignItems;\n    }\n\n    return 'stretch';\n  }\n\n  function getFlexDirection(node) {\n    if ('flexDirection' in node.style) {\n      return node.style.flexDirection;\n    }\n\n    return 'column';\n  }\n\n  function getPositionType(node) {\n    if ('position' in node.style) {\n      return node.style.position;\n    }\n\n    return 'relative';\n  }\n\n  function getFlex(node) {\n    return node.style.flex;\n  }\n\n  function isFlex(node) {\n    return getPositionType(node) === CSS_POSITION_RELATIVE && getFlex(node) > 0;\n  }\n\n  function isFlexWrap(node) {\n    return node.style.flexWrap === 'wrap';\n  }\n\n  function getDimWithMargin(node, axis) {\n    return node.layout[dim[axis]] + getMarginAxis(node, axis);\n  }\n\n  function isDimDefined(node, axis) {\n    return !isUndefined(node.style[dim[axis]]) && node.style[dim[axis]] >= 0;\n  }\n\n  function isPosDefined(node, pos) {\n    return !isUndefined(node.style[pos]);\n  }\n\n  function isMeasureDefined(node) {\n    return 'measure' in node.style;\n  }\n\n  function getPosition(node, pos) {\n    if (pos in node.style) {\n      return node.style[pos];\n    }\n\n    return 0;\n  } // When the user specifically sets a value for width or height\n\n\n  function setDimensionFromStyle(node, axis) {\n    // The parent already computed us a width or height. We just skip it\n    if (!isUndefined(node.layout[dim[axis]])) {\n      return;\n    } // We only run if there's a width or height defined\n\n\n    if (!isDimDefined(node, axis)) {\n      return;\n    } // The dimensions can never be smaller than the padding and border\n\n\n    node.layout[dim[axis]] = fmaxf(node.style[dim[axis]], getPaddingAndBorderAxis(node, axis));\n  } // If both left and right are defined, then use left. Otherwise return\n  // +left or -right depending on which is defined.\n\n\n  function getRelativePosition(node, axis) {\n    if (leading[axis] in node.style) {\n      return getPosition(node, leading[axis]);\n    }\n\n    return -getPosition(node, trailing[axis]);\n  }\n\n  var leading = {\n    row: 'left',\n    column: 'top'\n  };\n  var trailing = {\n    row: 'right',\n    column: 'bottom'\n  };\n  var pos = {\n    row: 'left',\n    column: 'top'\n  };\n  var dim = {\n    row: 'width',\n    column: 'height'\n  };\n\n  function fmaxf(a, b) {\n    if (a > b) {\n      return a;\n    }\n\n    return b;\n  }\n\n  var CSS_UNDEFINED = undefined;\n  var CSS_FLEX_DIRECTION_ROW = 'row';\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\n  var CSS_JUSTIFY_FLEX_START = 'flex-start';\n  var CSS_JUSTIFY_CENTER = 'center';\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n  var CSS_ALIGN_FLEX_START = 'flex-start';\n  var CSS_ALIGN_CENTER = 'center';\n  var CSS_ALIGN_FLEX_END = 'flex-end';\n  var CSS_ALIGN_STRETCH = 'stretch';\n  var CSS_POSITION_RELATIVE = 'relative';\n  var CSS_POSITION_ABSOLUTE = 'absolute';\n  return function layoutNode(node, parentMaxWidth) {\n    var\n    /*css_flex_direction_t*/\n    mainAxis = getFlexDirection(node);\n    var\n    /*css_flex_direction_t*/\n    crossAxis = mainAxis === CSS_FLEX_DIRECTION_ROW ? CSS_FLEX_DIRECTION_COLUMN : CSS_FLEX_DIRECTION_ROW; // Handle width and height style attributes\n\n    setDimensionFromStyle(node, mainAxis);\n    setDimensionFromStyle(node, crossAxis); // The position is set by the parent, but we need to complete it with a\n    // delta composed of the margin and left/top/right/bottom\n\n    node.layout[leading[mainAxis]] += getMargin(node, leading[mainAxis]) + getRelativePosition(node, mainAxis);\n    node.layout[leading[crossAxis]] += getMargin(node, leading[crossAxis]) + getRelativePosition(node, crossAxis);\n\n    if (isMeasureDefined(node)) {\n      var\n      /*float*/\n      width = CSS_UNDEFINED;\n\n      if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n        width = node.style.width;\n      } else if (!isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_ROW]])) {\n        width = node.layout[dim[CSS_FLEX_DIRECTION_ROW]];\n      } else {\n        width = parentMaxWidth - getMarginAxis(node, CSS_FLEX_DIRECTION_ROW);\n      }\n\n      width -= getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW); // We only need to give a dimension for the text if we haven't got any\n      // for it computed yet. It can either be from the style attribute or because\n      // the element is flexible.\n\n      var\n      /*bool*/\n      isRowUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_ROW) && isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_ROW]]);\n      var\n      /*bool*/\n      isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) && isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]); // Let's not measure the text if we already know both dimensions\n\n      if (isRowUndefined || isColumnUndefined) {\n        var\n        /*css_dim_t*/\n        measure_dim = node.style.measure(\n        /*(c)!node->context,*/\n        width);\n\n        if (isRowUndefined) {\n          node.layout.width = measure_dim.width + getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n        }\n\n        if (isColumnUndefined) {\n          node.layout.height = measure_dim.height + getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n        }\n      }\n\n      return;\n    } // Pre-fill some dimensions straight from the parent\n\n\n    for (var\n    /*int*/\n    i = 0; i < node.children.length; ++i) {\n      var\n      /*css_node_t**/\n      child = node.children[i]; // Pre-fill cross axis dimensions when the child is using stretch before\n      // we call the recursive layout pass\n\n      if (getAlignItem(node, child) === CSS_ALIGN_STRETCH && getPositionType(child) === CSS_POSITION_RELATIVE && !isUndefined(node.layout[dim[crossAxis]]) && !isDimDefined(child, crossAxis)) {\n        child.layout[dim[crossAxis]] = fmaxf(node.layout[dim[crossAxis]] - getPaddingAndBorderAxis(node, crossAxis) - getMarginAxis(child, crossAxis), // You never want to go smaller than padding\n        getPaddingAndBorderAxis(child, crossAxis));\n      } else if (getPositionType(child) == CSS_POSITION_ABSOLUTE) {\n        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n        // left and right or top and bottom).\n        for (var\n        /*int*/\n        ii = 0; ii < 2; ii++) {\n          var\n          /*css_flex_direction_t*/\n          axis = ii != 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\n          if (!isUndefined(node.layout[dim[axis]]) && !isDimDefined(child, axis) && isPosDefined(child, leading[axis]) && isPosDefined(child, trailing[axis])) {\n            child.layout[dim[axis]] = fmaxf(node.layout[dim[axis]] - getPaddingAndBorderAxis(node, axis) - getMarginAxis(child, axis) - getPosition(child, leading[axis]) - getPosition(child, trailing[axis]), // You never want to go smaller than padding\n            getPaddingAndBorderAxis(child, axis));\n          }\n        }\n      }\n    }\n\n    var\n    /*float*/\n    definedMainDim = CSS_UNDEFINED;\n\n    if (!isUndefined(node.layout[dim[mainAxis]])) {\n      definedMainDim = node.layout[dim[mainAxis]] - getPaddingAndBorderAxis(node, mainAxis);\n    } // We want to execute the next two loops one per line with flex-wrap\n\n\n    var\n    /*int*/\n    startLine = 0;\n    var\n    /*int*/\n    endLine = 0;\n    var\n    /*int*/\n    nextOffset = 0;\n    var\n    /*int*/\n    alreadyComputedNextLayout = 0; // We aggregate the total dimensions of the container in those two variables\n\n    var\n    /*float*/\n    linesCrossDim = 0;\n    var\n    /*float*/\n    linesMainDim = 0;\n\n    while (endLine < node.children.length) {\n      // <Loop A> Layout non flexible children and count children by type\n      // mainContentDim is accumulation of the dimensions and margin of all the\n      // non flexible children. This will be used in order to either set the\n      // dimensions of the node if none already exist, or to compute the\n      // remaining space left for the flexible children.\n      var\n      /*float*/\n      mainContentDim = 0; // There are three kind of children, non flexible, flexible and absolute.\n      // We need to know how many there are in order to distribute the space.\n\n      var\n      /*int*/\n      flexibleChildrenCount = 0;\n      var\n      /*float*/\n      totalFlexible = 0;\n      var\n      /*int*/\n      nonFlexibleChildrenCount = 0;\n\n      for (var\n      /*int*/\n      i = startLine; i < node.children.length; ++i) {\n        var\n        /*css_node_t**/\n        child = node.children[i];\n        var\n        /*float*/\n        nextContentDim = 0; // It only makes sense to consider a child flexible if we have a computed\n        // dimension for the node.\n\n        if (!isUndefined(node.layout[dim[mainAxis]]) && isFlex(child)) {\n          flexibleChildrenCount++;\n          totalFlexible += getFlex(child); // Even if we don't know its exact size yet, we already know the padding,\n          // border and margin. We'll use this partial information to compute the\n          // remaining space.\n\n          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) + getMarginAxis(child, mainAxis);\n        } else {\n          var\n          /*float*/\n          maxWidth = CSS_UNDEFINED;\n\n          if (mainAxis === CSS_FLEX_DIRECTION_ROW) {// do nothing\n          } else if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n            maxWidth = node.layout[dim[CSS_FLEX_DIRECTION_ROW]] - getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n          } else {\n            maxWidth = parentMaxWidth - getMarginAxis(node, CSS_FLEX_DIRECTION_ROW) - getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n          } // This is the main recursive call. We layout non flexible children.\n\n\n          if (alreadyComputedNextLayout === 0) {\n            layoutNode(child, maxWidth);\n          } // Absolute positioned elements do not take part of the layout, so we\n          // don't use them to compute mainContentDim\n\n\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            nonFlexibleChildrenCount++; // At this point we know the final size and margin of the element.\n\n            nextContentDim = getDimWithMargin(child, mainAxis);\n          }\n        } // The element we are about to add would make us go to the next line\n\n\n        if (isFlexWrap(node) && !isUndefined(node.layout[dim[mainAxis]]) && mainContentDim + nextContentDim > definedMainDim && // If there's only one element, then it's bigger than the content\n        // and needs its own line\n        i !== startLine) {\n          alreadyComputedNextLayout = 1;\n          break;\n        }\n\n        alreadyComputedNextLayout = 0;\n        mainContentDim += nextContentDim;\n        endLine = i + 1;\n      } // <Loop B> Layout flexible children and allocate empty space\n      // In order to position the elements in the main axis, we have two\n      // controls. The space between the beginning and the first element\n      // and the space between each two elements.\n\n\n      var\n      /*float*/\n      leadingMainDim = 0;\n      var\n      /*float*/\n      betweenMainDim = 0; // The remaining available space that needs to be allocated\n\n      var\n      /*float*/\n      remainingMainDim = 0;\n\n      if (!isUndefined(node.layout[dim[mainAxis]])) {\n        remainingMainDim = definedMainDim - mainContentDim;\n      } else {\n        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n      } // If there are flexible children in the mix, they are going to fill the\n      // remaining space\n\n\n      if (flexibleChildrenCount !== 0) {\n        var\n        /*float*/\n        flexibleMainDim = remainingMainDim / totalFlexible; // The non flexible children can overflow the container, in this case\n        // we should just assume that there is no space available.\n\n        if (flexibleMainDim < 0) {\n          flexibleMainDim = 0;\n        } // We iterate over the full array and only apply the action on flexible\n        // children. This is faster than actually allocating a new array that\n        // contains only flexible children.\n\n\n        for (var\n        /*int*/\n        i = startLine; i < endLine; ++i) {\n          var\n          /*css_node_t**/\n          child = node.children[i];\n\n          if (isFlex(child)) {\n            // At this point we know the final size of the element in the main\n            // dimension\n            child.layout[dim[mainAxis]] = flexibleMainDim * getFlex(child) + getPaddingAndBorderAxis(child, mainAxis);\n            var\n            /*float*/\n            maxWidth = CSS_UNDEFINED;\n\n            if (mainAxis === CSS_FLEX_DIRECTION_ROW) {// do nothing\n            } else if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n              maxWidth = node.layout[dim[CSS_FLEX_DIRECTION_ROW]] - getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n            } else {\n              maxWidth = parentMaxWidth - getMarginAxis(node, CSS_FLEX_DIRECTION_ROW) - getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n            } // And we recursively call the layout algorithm for this child\n\n\n            layoutNode(child, maxWidth);\n          }\n        } // We use justifyContent to figure out how to allocate the remaining\n        // space available\n\n      } else {\n        var\n        /*css_justify_t*/\n        justifyContent = getJustifyContent(node);\n\n        if (justifyContent === CSS_JUSTIFY_FLEX_START) {// Do nothing\n        } else if (justifyContent === CSS_JUSTIFY_CENTER) {\n          leadingMainDim = remainingMainDim / 2;\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n          leadingMainDim = remainingMainDim;\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n          remainingMainDim = fmaxf(remainingMainDim, 0);\n\n          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n            betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n          } else {\n            betweenMainDim = 0;\n          }\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n          // Space on the edges is half of the space between elements\n          betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount);\n          leadingMainDim = betweenMainDim / 2;\n        }\n      } // <Loop C> Position elements in the main axis and compute dimensions\n      // At this point, all the children have their dimensions set. We need to\n      // find their position. In order to do that, we accumulate data in\n      // variables that are also useful to compute the total dimensions of the\n      // container!\n\n\n      var\n      /*float*/\n      crossDim = 0;\n      var\n      /*float*/\n      mainDim = leadingMainDim + getPaddingAndBorder(node, leading[mainAxis]);\n\n      for (var\n      /*int*/\n      i = startLine; i < endLine; ++i) {\n        var\n        /*css_node_t**/\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[mainAxis])) {\n          // In case the child is position absolute and has left/top being\n          // defined, we override the position to whatever the user said\n          // (and margin/border).\n          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) + getBorder(node, leading[mainAxis]) + getMargin(child, leading[mainAxis]);\n        } else {\n          // If the child is position absolute (without top/left) or relative,\n          // we put it at the current accumulated offset.\n          child.layout[pos[mainAxis]] += mainDim;\n        } // Now that we placed the element, we need to update the variables\n        // We only need to do that for relative elements. Absolute elements\n        // do not take part in that phase.\n\n\n        if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n          // The main dimension is the sum of all the elements dimension plus\n          // the spacing.\n          mainDim += betweenMainDim + getDimWithMargin(child, mainAxis); // The cross dimension is the max of the elements dimension since there\n          // can only be one element in that cross dimension.\n\n          crossDim = fmaxf(crossDim, getDimWithMargin(child, crossAxis));\n        }\n      }\n\n      var\n      /*float*/\n      containerMainAxis = node.layout[dim[mainAxis]]; // If the user didn't specify a width or height, and it has not been set\n      // by the container, then we set it via the children.\n\n      if (isUndefined(node.layout[dim[mainAxis]])) {\n        containerMainAxis = fmaxf( // We're missing the last padding at this point to get the final\n        // dimension\n        mainDim + getPaddingAndBorder(node, trailing[mainAxis]), // We can never assign a width smaller than the padding and borders\n        getPaddingAndBorderAxis(node, mainAxis));\n      }\n\n      var\n      /*float*/\n      containerCrossAxis = node.layout[dim[crossAxis]];\n\n      if (isUndefined(node.layout[dim[crossAxis]])) {\n        containerCrossAxis = fmaxf( // For the cross dim, we add both sides at the end because the value\n        // is aggregate via a max function. Intermediate negative values\n        // can mess this computation otherwise\n        crossDim + getPaddingAndBorderAxis(node, crossAxis), getPaddingAndBorderAxis(node, crossAxis));\n      } // <Loop D> Position elements in the cross axis\n\n\n      for (var\n      /*int*/\n      i = startLine; i < endLine; ++i) {\n        var\n        /*css_node_t**/\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[crossAxis])) {\n          // In case the child is absolutely positionned and has a\n          // top/left/bottom/right being set, we override all the previously\n          // computed positions to set it correctly.\n          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) + getBorder(node, leading[crossAxis]) + getMargin(child, leading[crossAxis]);\n        } else {\n          var\n          /*float*/\n          leadingCrossDim = getPaddingAndBorder(node, leading[crossAxis]); // For a relative children, we're either using alignItems (parent) or\n          // alignSelf (child) in order to determine the position in the cross axis\n\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            var\n            /*css_align_t*/\n            alignItem = getAlignItem(node, child);\n\n            if (alignItem === CSS_ALIGN_FLEX_START) {// Do nothing\n            } else if (alignItem === CSS_ALIGN_STRETCH) {\n              // You can only stretch if the dimension has not already been set\n              // previously.\n              if (!isDimDefined(child, crossAxis)) {\n                child.layout[dim[crossAxis]] = fmaxf(containerCrossAxis - getPaddingAndBorderAxis(node, crossAxis) - getMarginAxis(child, crossAxis), // You never want to go smaller than padding\n                getPaddingAndBorderAxis(child, crossAxis));\n              }\n            } else {\n              // The remaining space between the parent dimensions+padding and child\n              // dimensions+margin.\n              var\n              /*float*/\n              remainingCrossDim = containerCrossAxis - getPaddingAndBorderAxis(node, crossAxis) - getDimWithMargin(child, crossAxis);\n\n              if (alignItem === CSS_ALIGN_CENTER) {\n                leadingCrossDim += remainingCrossDim / 2;\n              } else {\n                // CSS_ALIGN_FLEX_END\n                leadingCrossDim += remainingCrossDim;\n              }\n            }\n          } // And we apply the position\n\n\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n        }\n      }\n\n      linesCrossDim += crossDim;\n      linesMainDim = fmaxf(linesMainDim, mainDim);\n      startLine = endLine;\n    } // If the user didn't specify a width or height, and it has not been set\n    // by the container, then we set it via the children.\n\n\n    if (isUndefined(node.layout[dim[mainAxis]])) {\n      node.layout[dim[mainAxis]] = fmaxf( // We're missing the last padding at this point to get the final\n      // dimension\n      linesMainDim + getPaddingAndBorder(node, trailing[mainAxis]), // We can never assign a width smaller than the padding and borders\n      getPaddingAndBorderAxis(node, mainAxis));\n    }\n\n    if (isUndefined(node.layout[dim[crossAxis]])) {\n      node.layout[dim[crossAxis]] = fmaxf( // For the cross dim, we add both sides at the end because the value\n      // is aggregate via a max function. Intermediate negative values\n      // can mess this computation otherwise\n      linesCrossDim + getPaddingAndBorderAxis(node, crossAxis), getPaddingAndBorderAxis(node, crossAxis));\n    } // <Loop E> Calculate dimensions for absolutely positioned elements\n\n\n    for (var\n    /*int*/\n    i = 0; i < node.children.length; ++i) {\n      var\n      /*css_node_t**/\n      child = node.children[i];\n\n      if (getPositionType(child) == CSS_POSITION_ABSOLUTE) {\n        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n        // left and right or top and bottom).\n        for (var\n        /*int*/\n        ii = 0; ii < 2; ii++) {\n          var\n          /*css_flex_direction_t*/\n          axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\n          if (!isUndefined(node.layout[dim[axis]]) && !isDimDefined(child, axis) && isPosDefined(child, leading[axis]) && isPosDefined(child, trailing[axis])) {\n            child.layout[dim[axis]] = fmaxf(node.layout[dim[axis]] - getPaddingAndBorderAxis(node, axis) - getMarginAxis(child, axis) - getPosition(child, leading[axis]) - getPosition(child, trailing[axis]), // You never want to go smaller than padding\n            getPaddingAndBorderAxis(child, axis));\n          }\n        }\n\n        for (var\n        /*int*/\n        ii = 0; ii < 2; ii++) {\n          var\n          /*css_flex_direction_t*/\n          axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\n          if (isPosDefined(child, trailing[axis]) && !isPosDefined(child, leading[axis])) {\n            child.layout[leading[axis]] = node.layout[dim[axis]] - child.layout[dim[axis]] - getPosition(child, trailing[axis]);\n          }\n        }\n      }\n    }\n  };\n}();\n\nif (typeof module === 'object') {\n  module.exports = computeLayout;\n}","map":{"version":3,"sources":["C:/Users/sonwonjae/react/react-tutorial/canvas-example/node_modules/react-canvas/lib/Layout.js"],"names":["computeLayout","capitalizeFirst","str","charAt","toUpperCase","slice","getSpacing","node","type","suffix","location","key","style","getPositiveSpacing","isUndefined","value","undefined","getMargin","getPadding","getBorder","getPaddingAndBorder","getMarginAxis","axis","leading","trailing","getPaddingAndBorderAxis","getJustifyContent","justifyContent","getAlignItem","child","alignSelf","alignItems","getFlexDirection","flexDirection","getPositionType","position","getFlex","flex","isFlex","CSS_POSITION_RELATIVE","isFlexWrap","flexWrap","getDimWithMargin","layout","dim","isDimDefined","isPosDefined","pos","isMeasureDefined","getPosition","setDimensionFromStyle","fmaxf","getRelativePosition","row","column","a","b","CSS_UNDEFINED","CSS_FLEX_DIRECTION_ROW","CSS_FLEX_DIRECTION_COLUMN","CSS_JUSTIFY_FLEX_START","CSS_JUSTIFY_CENTER","CSS_JUSTIFY_FLEX_END","CSS_JUSTIFY_SPACE_BETWEEN","CSS_JUSTIFY_SPACE_AROUND","CSS_ALIGN_FLEX_START","CSS_ALIGN_CENTER","CSS_ALIGN_FLEX_END","CSS_ALIGN_STRETCH","CSS_POSITION_ABSOLUTE","layoutNode","parentMaxWidth","mainAxis","crossAxis","width","isRowUndefined","isColumnUndefined","measure_dim","measure","height","i","children","length","ii","definedMainDim","startLine","endLine","nextOffset","alreadyComputedNextLayout","linesCrossDim","linesMainDim","mainContentDim","flexibleChildrenCount","totalFlexible","nonFlexibleChildrenCount","nextContentDim","maxWidth","leadingMainDim","betweenMainDim","remainingMainDim","flexibleMainDim","crossDim","mainDim","containerMainAxis","containerCrossAxis","leadingCrossDim","alignItem","remainingCrossDim","module","exports"],"mappings":"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","sourcesContent":["// https://github.com/facebook/css-layout\n\n/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar computeLayout = (function() {\n\n  function capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function getSpacing(node, type, suffix, location) {\n    var key = type + capitalizeFirst(location) + suffix;\n    if (key in node.style) {\n      return node.style[key];\n    }\n\n    key = type + suffix;\n    if (key in node.style) {\n      return node.style[key];\n    }\n\n    return 0;\n  }\n\n  function getPositiveSpacing(node, type, suffix, location) {\n    var key = type + capitalizeFirst(location) + suffix;\n    if (key in node.style && node.style[key] >= 0) {\n      return node.style[key];\n    }\n\n    key = type + suffix;\n    if (key in node.style && node.style[key] >= 0) {\n      return node.style[key];\n    }\n\n    return 0;\n  }\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  function getMargin(node, location) {\n    return getSpacing(node, 'margin', '', location);\n  }\n\n  function getPadding(node, location) {\n    return getPositiveSpacing(node, 'padding', '', location);\n  }\n\n  function getBorder(node, location) {\n    return getPositiveSpacing(node, 'border', 'Width', location);\n  }\n\n  function getPaddingAndBorder(node, location) {\n    return getPadding(node, location) + getBorder(node, location);\n  }\n\n  function getMarginAxis(node, axis) {\n    return getMargin(node, leading[axis]) + getMargin(node, trailing[axis]);\n  }\n\n  function getPaddingAndBorderAxis(node, axis) {\n    return getPaddingAndBorder(node, leading[axis]) + getPaddingAndBorder(node, trailing[axis]);\n  }\n\n  function getJustifyContent(node) {\n    if ('justifyContent' in node.style) {\n      return node.style.justifyContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignItem(node, child) {\n    if ('alignSelf' in child.style) {\n      return child.style.alignSelf;\n    }\n    if ('alignItems' in node.style) {\n      return node.style.alignItems;\n    }\n    return 'stretch';\n  }\n\n  function getFlexDirection(node) {\n    if ('flexDirection' in node.style) {\n      return node.style.flexDirection;\n    }\n    return 'column';\n  }\n\n  function getPositionType(node) {\n    if ('position' in node.style) {\n      return node.style.position;\n    }\n    return 'relative';\n  }\n\n  function getFlex(node) {\n    return node.style.flex;\n  }\n\n  function isFlex(node) {\n    return (\n      getPositionType(node) === CSS_POSITION_RELATIVE &&\n      getFlex(node) > 0\n    );\n  }\n\n  function isFlexWrap(node) {\n    return node.style.flexWrap === 'wrap';\n  }\n\n  function getDimWithMargin(node, axis) {\n    return node.layout[dim[axis]] + getMarginAxis(node, axis);\n  }\n\n  function isDimDefined(node, axis) {\n    return !isUndefined(node.style[dim[axis]]) && node.style[dim[axis]] >= 0;\n  }\n\n  function isPosDefined(node, pos) {\n    return !isUndefined(node.style[pos]);\n  }\n\n  function isMeasureDefined(node) {\n    return 'measure' in node.style;\n  }\n\n  function getPosition(node, pos) {\n    if (pos in node.style) {\n      return node.style[pos];\n    }\n    return 0;\n  }\n\n  // When the user specifically sets a value for width or height\n  function setDimensionFromStyle(node, axis) {\n    // The parent already computed us a width or height. We just skip it\n    if (!isUndefined(node.layout[dim[axis]])) {\n      return;\n    }\n    // We only run if there's a width or height defined\n    if (!isDimDefined(node, axis)) {\n      return;\n    }\n\n    // The dimensions can never be smaller than the padding and border\n    node.layout[dim[axis]] = fmaxf(\n      node.style[dim[axis]],\n      getPaddingAndBorderAxis(node, axis)\n    );\n  }\n\n  // If both left and right are defined, then use left. Otherwise return\n  // +left or -right depending on which is defined.\n  function getRelativePosition(node, axis) {\n    if (leading[axis] in node.style) {\n      return getPosition(node, leading[axis]);\n    }\n    return -getPosition(node, trailing[axis]);\n  }\n\n  var leading = {\n    row: 'left',\n    column: 'top'\n  };\n  var trailing = {\n    row: 'right',\n    column: 'bottom'\n  };\n  var pos = {\n    row: 'left',\n    column: 'top'\n  };\n  var dim = {\n    row: 'width',\n    column: 'height'\n  };\n\n  function fmaxf(a, b) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  var CSS_UNDEFINED = undefined;\n\n  var CSS_FLEX_DIRECTION_ROW = 'row';\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\n\n  var CSS_JUSTIFY_FLEX_START = 'flex-start';\n  var CSS_JUSTIFY_CENTER = 'center';\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n  var CSS_ALIGN_FLEX_START = 'flex-start';\n  var CSS_ALIGN_CENTER = 'center';\n  var CSS_ALIGN_FLEX_END = 'flex-end';\n  var CSS_ALIGN_STRETCH = 'stretch';\n\n  var CSS_POSITION_RELATIVE = 'relative';\n  var CSS_POSITION_ABSOLUTE = 'absolute';\n\n  return function layoutNode(node, parentMaxWidth) {\n    var/*css_flex_direction_t*/ mainAxis = getFlexDirection(node);\n    var/*css_flex_direction_t*/ crossAxis = mainAxis === CSS_FLEX_DIRECTION_ROW ?\n      CSS_FLEX_DIRECTION_COLUMN :\n      CSS_FLEX_DIRECTION_ROW;\n\n    // Handle width and height style attributes\n    setDimensionFromStyle(node, mainAxis);\n    setDimensionFromStyle(node, crossAxis);\n\n    // The position is set by the parent, but we need to complete it with a\n    // delta composed of the margin and left/top/right/bottom\n    node.layout[leading[mainAxis]] += getMargin(node, leading[mainAxis]) +\n      getRelativePosition(node, mainAxis);\n    node.layout[leading[crossAxis]] += getMargin(node, leading[crossAxis]) +\n      getRelativePosition(node, crossAxis);\n\n    if (isMeasureDefined(node)) {\n      var/*float*/ width = CSS_UNDEFINED;\n      if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n        width = node.style.width;\n      } else if (!isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_ROW]])) {\n        width = node.layout[dim[CSS_FLEX_DIRECTION_ROW]];\n      } else {\n        width = parentMaxWidth -\n          getMarginAxis(node, CSS_FLEX_DIRECTION_ROW);\n      }\n      width -= getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n\n      // We only need to give a dimension for the text if we haven't got any\n      // for it computed yet. It can either be from the style attribute or because\n      // the element is flexible.\n      var/*bool*/ isRowUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_ROW) &&\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_ROW]]);\n      var/*bool*/ isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\n\n      // Let's not measure the text if we already know both dimensions\n      if (isRowUndefined || isColumnUndefined) {\n        var/*css_dim_t*/ measure_dim = node.style.measure(\n          /*(c)!node->context,*/\n          width\n        );\n        if (isRowUndefined) {\n          node.layout.width = measure_dim.width +\n            getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n        }\n        if (isColumnUndefined) {\n          node.layout.height = measure_dim.height +\n            getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n        }\n      }\n      return;\n    }\n\n    // Pre-fill some dimensions straight from the parent\n    for (var/*int*/ i = 0; i < node.children.length; ++i) {\n      var/*css_node_t**/ child = node.children[i];\n      // Pre-fill cross axis dimensions when the child is using stretch before\n      // we call the recursive layout pass\n      if (getAlignItem(node, child) === CSS_ALIGN_STRETCH &&\n          getPositionType(child) === CSS_POSITION_RELATIVE &&\n          !isUndefined(node.layout[dim[crossAxis]]) &&\n          !isDimDefined(child, crossAxis)) {\n        child.layout[dim[crossAxis]] = fmaxf(\n          node.layout[dim[crossAxis]] -\n            getPaddingAndBorderAxis(node, crossAxis) -\n            getMarginAxis(child, crossAxis),\n          // You never want to go smaller than padding\n          getPaddingAndBorderAxis(child, crossAxis)\n        );\n      } else if (getPositionType(child) == CSS_POSITION_ABSOLUTE) {\n        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n        // left and right or top and bottom).\n        for (var/*int*/ ii = 0; ii < 2; ii++) {\n          var/*css_flex_direction_t*/ axis = (ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (!isUndefined(node.layout[dim[axis]]) &&\n              !isDimDefined(child, axis) &&\n              isPosDefined(child, leading[axis]) &&\n              isPosDefined(child, trailing[axis])) {\n            child.layout[dim[axis]] = fmaxf(\n              node.layout[dim[axis]] -\n              getPaddingAndBorderAxis(node, axis) -\n              getMarginAxis(child, axis) -\n              getPosition(child, leading[axis]) -\n              getPosition(child, trailing[axis]),\n              // You never want to go smaller than padding\n              getPaddingAndBorderAxis(child, axis)\n            );\n          }\n        }\n      }\n    }\n\n    var/*float*/ definedMainDim = CSS_UNDEFINED;\n    if (!isUndefined(node.layout[dim[mainAxis]])) {\n      definedMainDim = node.layout[dim[mainAxis]] -\n          getPaddingAndBorderAxis(node, mainAxis);\n    }\n\n    // We want to execute the next two loops one per line with flex-wrap\n    var/*int*/ startLine = 0;\n    var/*int*/ endLine = 0;\n    var/*int*/ nextOffset = 0;\n    var/*int*/ alreadyComputedNextLayout = 0;\n    // We aggregate the total dimensions of the container in those two variables\n    var/*float*/ linesCrossDim = 0;\n    var/*float*/ linesMainDim = 0;\n    while (endLine < node.children.length) {\n      // <Loop A> Layout non flexible children and count children by type\n\n      // mainContentDim is accumulation of the dimensions and margin of all the\n      // non flexible children. This will be used in order to either set the\n      // dimensions of the node if none already exist, or to compute the\n      // remaining space left for the flexible children.\n      var/*float*/ mainContentDim = 0;\n\n      // There are three kind of children, non flexible, flexible and absolute.\n      // We need to know how many there are in order to distribute the space.\n      var/*int*/ flexibleChildrenCount = 0;\n      var/*float*/ totalFlexible = 0;\n      var/*int*/ nonFlexibleChildrenCount = 0;\n      for (var/*int*/ i = startLine; i < node.children.length; ++i) {\n        var/*css_node_t**/ child = node.children[i];\n        var/*float*/ nextContentDim = 0;\n\n        // It only makes sense to consider a child flexible if we have a computed\n        // dimension for the node.\n        if (!isUndefined(node.layout[dim[mainAxis]]) && isFlex(child)) {\n          flexibleChildrenCount++;\n          totalFlexible += getFlex(child);\n\n          // Even if we don't know its exact size yet, we already know the padding,\n          // border and margin. We'll use this partial information to compute the\n          // remaining space.\n          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\n            getMarginAxis(child, mainAxis);\n\n        } else {\n          var/*float*/ maxWidth = CSS_UNDEFINED;\n          if (mainAxis === CSS_FLEX_DIRECTION_ROW) {\n            // do nothing\n          } else if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n            maxWidth = node.layout[dim[CSS_FLEX_DIRECTION_ROW]] -\n              getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n          } else {\n            maxWidth = parentMaxWidth -\n              getMarginAxis(node, CSS_FLEX_DIRECTION_ROW) -\n              getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n          }\n\n          // This is the main recursive call. We layout non flexible children.\n          if (alreadyComputedNextLayout === 0) {\n            layoutNode(child, maxWidth);\n          }\n\n          // Absolute positioned elements do not take part of the layout, so we\n          // don't use them to compute mainContentDim\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            nonFlexibleChildrenCount++;\n            // At this point we know the final size and margin of the element.\n            nextContentDim = getDimWithMargin(child, mainAxis);\n          }\n        }\n\n        // The element we are about to add would make us go to the next line\n        if (isFlexWrap(node) &&\n            !isUndefined(node.layout[dim[mainAxis]]) &&\n            mainContentDim + nextContentDim > definedMainDim &&\n            // If there's only one element, then it's bigger than the content\n            // and needs its own line\n            i !== startLine) {\n          alreadyComputedNextLayout = 1;\n          break;\n        }\n        alreadyComputedNextLayout = 0;\n        mainContentDim += nextContentDim;\n        endLine = i + 1;\n      }\n\n      // <Loop B> Layout flexible children and allocate empty space\n\n      // In order to position the elements in the main axis, we have two\n      // controls. The space between the beginning and the first element\n      // and the space between each two elements.\n      var/*float*/ leadingMainDim = 0;\n      var/*float*/ betweenMainDim = 0;\n\n      // The remaining available space that needs to be allocated\n      var/*float*/ remainingMainDim = 0;\n      if (!isUndefined(node.layout[dim[mainAxis]])) {\n        remainingMainDim = definedMainDim - mainContentDim;\n      } else {\n        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n      }\n\n      // If there are flexible children in the mix, they are going to fill the\n      // remaining space\n      if (flexibleChildrenCount !== 0) {\n        var/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\n\n        // The non flexible children can overflow the container, in this case\n        // we should just assume that there is no space available.\n        if (flexibleMainDim < 0) {\n          flexibleMainDim = 0;\n        }\n        // We iterate over the full array and only apply the action on flexible\n        // children. This is faster than actually allocating a new array that\n        // contains only flexible children.\n        for (var/*int*/ i = startLine; i < endLine; ++i) {\n          var/*css_node_t**/ child = node.children[i];\n          if (isFlex(child)) {\n            // At this point we know the final size of the element in the main\n            // dimension\n            child.layout[dim[mainAxis]] = flexibleMainDim * getFlex(child) +\n              getPaddingAndBorderAxis(child, mainAxis);\n\n            var/*float*/ maxWidth = CSS_UNDEFINED;\n            if (mainAxis === CSS_FLEX_DIRECTION_ROW) {\n              // do nothing\n            } else if (isDimDefined(node, CSS_FLEX_DIRECTION_ROW)) {\n              maxWidth = node.layout[dim[CSS_FLEX_DIRECTION_ROW]] -\n                getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n            } else {\n              maxWidth = parentMaxWidth -\n                getMarginAxis(node, CSS_FLEX_DIRECTION_ROW) -\n                getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_ROW);\n            }\n\n            // And we recursively call the layout algorithm for this child\n            layoutNode(child, maxWidth);\n          }\n        }\n\n      // We use justifyContent to figure out how to allocate the remaining\n      // space available\n      } else {\n        var/*css_justify_t*/ justifyContent = getJustifyContent(node);\n        if (justifyContent === CSS_JUSTIFY_FLEX_START) {\n          // Do nothing\n        } else if (justifyContent === CSS_JUSTIFY_CENTER) {\n          leadingMainDim = remainingMainDim / 2;\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n          leadingMainDim = remainingMainDim;\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n          remainingMainDim = fmaxf(remainingMainDim, 0);\n          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n            betweenMainDim = remainingMainDim /\n              (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n          } else {\n            betweenMainDim = 0;\n          }\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n          // Space on the edges is half of the space between elements\n          betweenMainDim = remainingMainDim /\n            (flexibleChildrenCount + nonFlexibleChildrenCount);\n          leadingMainDim = betweenMainDim / 2;\n        }\n      }\n\n      // <Loop C> Position elements in the main axis and compute dimensions\n\n      // At this point, all the children have their dimensions set. We need to\n      // find their position. In order to do that, we accumulate data in\n      // variables that are also useful to compute the total dimensions of the\n      // container!\n      var/*float*/ crossDim = 0;\n      var/*float*/ mainDim = leadingMainDim +\n        getPaddingAndBorder(node, leading[mainAxis]);\n\n      for (var/*int*/ i = startLine; i < endLine; ++i) {\n        var/*css_node_t**/ child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[mainAxis])) {\n          // In case the child is position absolute and has left/top being\n          // defined, we override the position to whatever the user said\n          // (and margin/border).\n          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\n            getBorder(node, leading[mainAxis]) +\n            getMargin(child, leading[mainAxis]);\n        } else {\n          // If the child is position absolute (without top/left) or relative,\n          // we put it at the current accumulated offset.\n          child.layout[pos[mainAxis]] += mainDim;\n        }\n\n        // Now that we placed the element, we need to update the variables\n        // We only need to do that for relative elements. Absolute elements\n        // do not take part in that phase.\n        if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n          // The main dimension is the sum of all the elements dimension plus\n          // the spacing.\n          mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n          // The cross dimension is the max of the elements dimension since there\n          // can only be one element in that cross dimension.\n          crossDim = fmaxf(crossDim, getDimWithMargin(child, crossAxis));\n        }\n      }\n\n      var/*float*/ containerMainAxis = node.layout[dim[mainAxis]];\n      // If the user didn't specify a width or height, and it has not been set\n      // by the container, then we set it via the children.\n      if (isUndefined(node.layout[dim[mainAxis]])) {\n        containerMainAxis = fmaxf(\n          // We're missing the last padding at this point to get the final\n          // dimension\n          mainDim + getPaddingAndBorder(node, trailing[mainAxis]),\n          // We can never assign a width smaller than the padding and borders\n          getPaddingAndBorderAxis(node, mainAxis)\n        );\n      }\n\n      var/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\n      if (isUndefined(node.layout[dim[crossAxis]])) {\n        containerCrossAxis = fmaxf(\n          // For the cross dim, we add both sides at the end because the value\n          // is aggregate via a max function. Intermediate negative values\n          // can mess this computation otherwise\n          crossDim + getPaddingAndBorderAxis(node, crossAxis),\n          getPaddingAndBorderAxis(node, crossAxis)\n        );\n      }\n\n      // <Loop D> Position elements in the cross axis\n\n      for (var/*int*/ i = startLine; i < endLine; ++i) {\n        var/*css_node_t**/ child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[crossAxis])) {\n          // In case the child is absolutely positionned and has a\n          // top/left/bottom/right being set, we override all the previously\n          // computed positions to set it correctly.\n          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\n            getBorder(node, leading[crossAxis]) +\n            getMargin(child, leading[crossAxis]);\n\n        } else {\n          var/*float*/ leadingCrossDim = getPaddingAndBorder(node, leading[crossAxis]);\n\n          // For a relative children, we're either using alignItems (parent) or\n          // alignSelf (child) in order to determine the position in the cross axis\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            var/*css_align_t*/ alignItem = getAlignItem(node, child);\n            if (alignItem === CSS_ALIGN_FLEX_START) {\n              // Do nothing\n            } else if (alignItem === CSS_ALIGN_STRETCH) {\n              // You can only stretch if the dimension has not already been set\n              // previously.\n              if (!isDimDefined(child, crossAxis)) {\n                child.layout[dim[crossAxis]] = fmaxf(\n                  containerCrossAxis -\n                    getPaddingAndBorderAxis(node, crossAxis) -\n                    getMarginAxis(child, crossAxis),\n                  // You never want to go smaller than padding\n                  getPaddingAndBorderAxis(child, crossAxis)\n                );\n              }\n            } else {\n              // The remaining space between the parent dimensions+padding and child\n              // dimensions+margin.\n              var/*float*/ remainingCrossDim = containerCrossAxis -\n                getPaddingAndBorderAxis(node, crossAxis) -\n                getDimWithMargin(child, crossAxis);\n\n              if (alignItem === CSS_ALIGN_CENTER) {\n                leadingCrossDim += remainingCrossDim / 2;\n              } else { // CSS_ALIGN_FLEX_END\n                leadingCrossDim += remainingCrossDim;\n              }\n            }\n          }\n\n          // And we apply the position\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n        }\n      }\n\n      linesCrossDim += crossDim;\n      linesMainDim = fmaxf(linesMainDim, mainDim);\n      startLine = endLine;\n    }\n\n    // If the user didn't specify a width or height, and it has not been set\n    // by the container, then we set it via the children.\n    if (isUndefined(node.layout[dim[mainAxis]])) {\n      node.layout[dim[mainAxis]] = fmaxf(\n        // We're missing the last padding at this point to get the final\n        // dimension\n        linesMainDim + getPaddingAndBorder(node, trailing[mainAxis]),\n        // We can never assign a width smaller than the padding and borders\n        getPaddingAndBorderAxis(node, mainAxis)\n      );\n    }\n\n    if (isUndefined(node.layout[dim[crossAxis]])) {\n      node.layout[dim[crossAxis]] = fmaxf(\n        // For the cross dim, we add both sides at the end because the value\n        // is aggregate via a max function. Intermediate negative values\n        // can mess this computation otherwise\n        linesCrossDim + getPaddingAndBorderAxis(node, crossAxis),\n        getPaddingAndBorderAxis(node, crossAxis)\n      );\n    }\n\n    // <Loop E> Calculate dimensions for absolutely positioned elements\n\n    for (var/*int*/ i = 0; i < node.children.length; ++i) {\n      var/*css_node_t**/ child = node.children[i];\n      if (getPositionType(child) == CSS_POSITION_ABSOLUTE) {\n        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n        // left and right or top and bottom).\n        for (var/*int*/ ii = 0; ii < 2; ii++) {\n          var/*css_flex_direction_t*/ axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (!isUndefined(node.layout[dim[axis]]) &&\n              !isDimDefined(child, axis) &&\n              isPosDefined(child, leading[axis]) &&\n              isPosDefined(child, trailing[axis])) {\n            child.layout[dim[axis]] = fmaxf(\n              node.layout[dim[axis]] -\n              getPaddingAndBorderAxis(node, axis) -\n              getMarginAxis(child, axis) -\n              getPosition(child, leading[axis]) -\n              getPosition(child, trailing[axis]),\n              // You never want to go smaller than padding\n              getPaddingAndBorderAxis(child, axis)\n            );\n          }\n        }\n        for (var/*int*/ ii = 0; ii < 2; ii++) {\n          var/*css_flex_direction_t*/ axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (isPosDefined(child, trailing[axis]) &&\n              !isPosDefined(child, leading[axis])) {\n            child.layout[leading[axis]] =\n              node.layout[dim[axis]] -\n              child.layout[dim[axis]] -\n              getPosition(child, trailing[axis]);\n          }\n        }\n      }\n    }\n  };\n})();\n\nif (typeof module === 'object') {\n  module.exports = computeLayout;\n}\n"]},"metadata":{},"sourceType":"script"}