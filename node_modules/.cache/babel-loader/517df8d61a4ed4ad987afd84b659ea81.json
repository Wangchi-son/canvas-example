{"ast":null,"code":"/*\r\n * Scroller\r\n * http://github.com/zynga/scroller\r\n *\r\n * Copyright 2011, Zynga Inc.\r\n * Licensed under the MIT License.\r\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\r\n *\r\n * Based on the work of: Unify Project (unify-project.org)\r\n * http://unify-project.org\r\n * Copyright 2011, Deutsche Telekom AG\r\n * License: MIT + Apache (V2)\r\n */\nvar core = require('./Animate');\n\nvar Scroller;\n\n(function () {\n  var NOOP = function () {};\n  /**\r\n   * A pure logic 'component' for 'virtual' scrolling/zooming.\r\n   */\n\n\n  Scroller = function (callback, options) {\n    this.__callback = callback;\n    this.options = {\n      /** Enable scrolling on x-axis */\n      scrollingX: true,\n\n      /** Enable scrolling on y-axis */\n      scrollingY: true,\n\n      /** Enable animations for deceleration, snap back, zooming and scrolling */\n      animating: true,\n\n      /** duration for animations triggered by scrollTo/zoomTo */\n      animationDuration: 250,\n\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n      bouncing: true,\n\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\n      locking: true,\n\n      /** Enable pagination mode (switching between full page content panes) */\n      paging: false,\n\n      /** Enable snapping of content to a configured pixel grid */\n      snapping: false,\n\n      /** Enable zooming of content via API, fingers and mouse wheel */\n      zooming: false,\n\n      /** Minimum zoom level */\n      minZoom: 0.5,\n\n      /** Maximum zoom level */\n      maxZoom: 3,\n\n      /** Multiply or decrease scrolling speed **/\n      speedMultiplier: 1,\n\n      /** Callback that is fired on the later of touch end or deceleration end,\r\n      \tprovided that another scrolling action has not begun. Used to know\r\n      \twhen to fade out a scrollbar. */\n      scrollingComplete: NOOP,\n\n      /** Increase or decrease the amount of friction applied to deceleration **/\n      decelerationRate: 0.95,\n\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n      penetrationDeceleration: 0.03,\n\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n      penetrationAcceleration: 0.08\n    };\n\n    for (var key in options) {\n      this.options[key] = options[key];\n    }\n  }; // Easing Equations (c) 2003 Robert Penner, all rights reserved.\n  // Open source under the BSD License.\n\n  /**\r\n   * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\r\n  **/\n\n\n  var easeOutCubic = function (pos) {\n    return Math.pow(pos - 1, 3) + 1;\n  };\n  /**\r\n   * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\r\n  **/\n\n\n  var easeInOutCubic = function (pos) {\n    if ((pos /= 0.5) < 1) {\n      return 0.5 * Math.pow(pos, 3);\n    }\n\n    return 0.5 * (Math.pow(pos - 2, 3) + 2);\n  };\n\n  var members = {\n    /*\r\n    ---------------------------------------------------------------------------\r\n    \tINTERNAL FIELDS :: STATUS\r\n    ---------------------------------------------------------------------------\r\n    */\n\n    /** {Boolean} Whether only a single finger is used in touch handling */\n    __isSingleTouch: false,\n\n    /** {Boolean} Whether a touch event sequence is in progress */\n    __isTracking: false,\n\n    /** {Boolean} Whether a deceleration animation went to completion. */\n    __didDecelerationComplete: false,\n\n    /**\r\n     * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\r\n     * a gesturestart event happens. This has higher priority than dragging.\r\n     */\n    __isGesturing: false,\n\n    /**\r\n     * {Boolean} Whether the user has moved by such a distance that we have enabled\r\n     * dragging mode. Hint: It's only enabled after some pixels of movement to\r\n     * not interrupt with clicks etc.\r\n     */\n    __isDragging: false,\n\n    /**\r\n     * {Boolean} Not touching and dragging anymore, and smoothly animating the\r\n     * touch sequence using deceleration.\r\n     */\n    __isDecelerating: false,\n\n    /**\r\n     * {Boolean} Smoothly animating the currently configured change\r\n     */\n    __isAnimating: false,\n\n    /*\r\n    ---------------------------------------------------------------------------\r\n    \tINTERNAL FIELDS :: DIMENSIONS\r\n    ---------------------------------------------------------------------------\r\n    */\n\n    /** {Integer} Available outer left position (from document perspective) */\n    __clientLeft: 0,\n\n    /** {Integer} Available outer top position (from document perspective) */\n    __clientTop: 0,\n\n    /** {Integer} Available outer width */\n    __clientWidth: 0,\n\n    /** {Integer} Available outer height */\n    __clientHeight: 0,\n\n    /** {Integer} Outer width of content */\n    __contentWidth: 0,\n\n    /** {Integer} Outer height of content */\n    __contentHeight: 0,\n\n    /** {Integer} Snapping width for content */\n    __snapWidth: 100,\n\n    /** {Integer} Snapping height for content */\n    __snapHeight: 100,\n\n    /** {Integer} Height to assign to refresh area */\n    __refreshHeight: null,\n\n    /** {Boolean} Whether the refresh process is enabled when the event is released now */\n    __refreshActive: false,\n\n    /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n    __refreshActivate: null,\n\n    /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n    __refreshDeactivate: null,\n\n    /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n    __refreshStart: null,\n\n    /** {Number} Zoom level */\n    __zoomLevel: 1,\n\n    /** {Number} Scroll position on x-axis */\n    __scrollLeft: 0,\n\n    /** {Number} Scroll position on y-axis */\n    __scrollTop: 0,\n\n    /** {Integer} Maximum allowed scroll position on x-axis */\n    __maxScrollLeft: 0,\n\n    /** {Integer} Maximum allowed scroll position on y-axis */\n    __maxScrollTop: 0,\n\n    /* {Number} Scheduled left position (final position when animating) */\n    __scheduledLeft: 0,\n\n    /* {Number} Scheduled top position (final position when animating) */\n    __scheduledTop: 0,\n\n    /* {Number} Scheduled zoom level (final scale when animating) */\n    __scheduledZoom: 0,\n\n    /*\r\n    ---------------------------------------------------------------------------\r\n    \tINTERNAL FIELDS :: LAST POSITIONS\r\n    ---------------------------------------------------------------------------\r\n    */\n\n    /** {Number} Left position of finger at start */\n    __lastTouchLeft: null,\n\n    /** {Number} Top position of finger at start */\n    __lastTouchTop: null,\n\n    /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n    __lastTouchMove: null,\n\n    /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n    __positions: null,\n\n    /*\r\n    ---------------------------------------------------------------------------\r\n    \tINTERNAL FIELDS :: DECELERATION SUPPORT\r\n    ---------------------------------------------------------------------------\r\n    */\n\n    /** {Integer} Minimum left scroll position during deceleration */\n    __minDecelerationScrollLeft: null,\n\n    /** {Integer} Minimum top scroll position during deceleration */\n    __minDecelerationScrollTop: null,\n\n    /** {Integer} Maximum left scroll position during deceleration */\n    __maxDecelerationScrollLeft: null,\n\n    /** {Integer} Maximum top scroll position during deceleration */\n    __maxDecelerationScrollTop: null,\n\n    /** {Number} Current factor to modify horizontal scroll position with on every step */\n    __decelerationVelocityX: null,\n\n    /** {Number} Current factor to modify vertical scroll position with on every step */\n    __decelerationVelocityY: null,\n\n    /*\r\n    ---------------------------------------------------------------------------\r\n    \tPUBLIC API\r\n    ---------------------------------------------------------------------------\r\n    */\n\n    /**\r\n     * Configures the dimensions of the client (outer) and content (inner) elements.\r\n     * Requires the available space for the outer element and the outer size of the inner element.\r\n     * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\r\n     *\r\n     * @param clientWidth {Integer ? null} Inner width of outer element\r\n     * @param clientHeight {Integer ? null} Inner height of outer element\r\n     * @param contentWidth {Integer ? null} Outer width of inner element\r\n     * @param contentHeight {Integer ? null} Outer height of inner element\r\n     */\n    setDimensions: function (clientWidth, clientHeight, contentWidth, contentHeight) {\n      var self = this; // Only update values which are defined\n\n      if (clientWidth === +clientWidth) {\n        self.__clientWidth = clientWidth;\n      }\n\n      if (clientHeight === +clientHeight) {\n        self.__clientHeight = clientHeight;\n      }\n\n      if (contentWidth === +contentWidth) {\n        self.__contentWidth = contentWidth;\n      }\n\n      if (contentHeight === +contentHeight) {\n        self.__contentHeight = contentHeight;\n      } // Refresh maximums\n\n\n      self.__computeScrollMax(); // Refresh scroll position\n\n\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    },\n\n    /**\r\n     * Sets the client coordinates in relation to the document.\r\n     *\r\n     * @param left {Integer ? 0} Left position of outer element\r\n     * @param top {Integer ? 0} Top position of outer element\r\n     */\n    setPosition: function (left, top) {\n      var self = this;\n      self.__clientLeft = left || 0;\n      self.__clientTop = top || 0;\n    },\n\n    /**\r\n     * Configures the snapping (when snapping is active)\r\n     *\r\n     * @param width {Integer} Snapping width\r\n     * @param height {Integer} Snapping height\r\n     */\n    setSnapSize: function (width, height) {\n      var self = this;\n      self.__snapWidth = width;\n      self.__snapHeight = height;\n    },\n\n    /**\r\n     * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\r\n     * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\r\n     * the official Twitter client.\r\n     *\r\n     * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\r\n     * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\r\n     * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\r\n     * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\r\n     */\n    activatePullToRefresh: function (height, activateCallback, deactivateCallback, startCallback) {\n      var self = this;\n      self.__refreshHeight = height;\n      self.__refreshActivate = activateCallback;\n      self.__refreshDeactivate = deactivateCallback;\n      self.__refreshStart = startCallback;\n    },\n\n    /**\r\n     * Starts pull-to-refresh manually.\r\n     */\n    triggerPullToRefresh: function () {\n      // Use publish instead of scrollTo to allow scrolling to out of boundary position\n      // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n      this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);\n\n      if (this.__refreshStart) {\n        this.__refreshStart();\n      }\n    },\n\n    /**\r\n     * Signalizes that pull-to-refresh is finished.\r\n     */\n    finishPullToRefresh: function () {\n      var self = this;\n      self.__refreshActive = false;\n\n      if (self.__refreshDeactivate) {\n        self.__refreshDeactivate();\n      }\n\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    },\n\n    /**\r\n     * Returns the scroll position and zooming values\r\n     *\r\n     * @return {Map} `left` and `top` scroll position and `zoom` level\r\n     */\n    getValues: function () {\n      var self = this;\n      return {\n        left: self.__scrollLeft,\n        top: self.__scrollTop,\n        zoom: self.__zoomLevel\n      };\n    },\n\n    /**\r\n     * Returns the maximum scroll values\r\n     *\r\n     * @return {Map} `left` and `top` maximum scroll values\r\n     */\n    getScrollMax: function () {\n      var self = this;\n      return {\n        left: self.__maxScrollLeft,\n        top: self.__maxScrollTop\n      };\n    },\n\n    /**\r\n     * Zooms to the given level. Supports optional animation. Zooms\r\n     * the center when no coordinates are given.\r\n     *\r\n     * @param level {Number} Level to zoom to\r\n     * @param animate {Boolean ? false} Whether to use animation\r\n     * @param originLeft {Number ? null} Zoom in at given left coordinate\r\n     * @param originTop {Number ? null} Zoom in at given top coordinate\r\n     * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\r\n     */\n    zoomTo: function (level, animate, originLeft, originTop, callback) {\n      var self = this;\n\n      if (!self.options.zooming) {\n        throw new Error(\"Zooming is not enabled!\");\n      } // Add callback if exists\n\n\n      if (callback) {\n        self.__zoomComplete = callback;\n      } // Stop deceleration\n\n\n      if (self.__isDecelerating) {\n        core.effect.Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n      }\n\n      var oldLevel = self.__zoomLevel; // Normalize input origin to center of viewport if not defined\n\n      if (originLeft == null) {\n        originLeft = self.__clientWidth / 2;\n      }\n\n      if (originTop == null) {\n        originTop = self.__clientHeight / 2;\n      } // Limit level according to configuration\n\n\n      level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom); // Recompute maximum values while temporary tweaking maximum scroll ranges\n\n      self.__computeScrollMax(level); // Recompute left and top coordinates based on new zoom level\n\n\n      var left = (originLeft + self.__scrollLeft) * level / oldLevel - originLeft;\n      var top = (originTop + self.__scrollTop) * level / oldLevel - originTop; // Limit x-axis\n\n      if (left > self.__maxScrollLeft) {\n        left = self.__maxScrollLeft;\n      } else if (left < 0) {\n        left = 0;\n      } // Limit y-axis\n\n\n      if (top > self.__maxScrollTop) {\n        top = self.__maxScrollTop;\n      } else if (top < 0) {\n        top = 0;\n      } // Push values out\n\n\n      self.__publish(left, top, level, animate);\n    },\n\n    /**\r\n     * Zooms the content by the given factor.\r\n     *\r\n     * @param factor {Number} Zoom by given factor\r\n     * @param animate {Boolean ? false} Whether to use animation\r\n     * @param originLeft {Number ? 0} Zoom in at given left coordinate\r\n     * @param originTop {Number ? 0} Zoom in at given top coordinate\r\n     * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\r\n     */\n    zoomBy: function (factor, animate, originLeft, originTop, callback) {\n      var self = this;\n      self.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop, callback);\n    },\n\n    /**\r\n     * Scrolls to the given position. Respect limitations and snapping automatically.\r\n     *\r\n     * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\r\n     * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\r\n     * @param animate {Boolean?false} Whether the scrolling should happen using an animation\r\n     * @param zoom {Number?null} Zoom level to go to\r\n     */\n    scrollTo: function (left, top, animate, zoom) {\n      var self = this; // Stop deceleration\n\n      if (self.__isDecelerating) {\n        core.effect.Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n      } // Correct coordinates based on new zoom level\n\n\n      if (zoom != null && zoom !== self.__zoomLevel) {\n        if (!self.options.zooming) {\n          throw new Error(\"Zooming is not enabled!\");\n        }\n\n        left *= zoom;\n        top *= zoom; // Recompute maximum values while temporary tweaking maximum scroll ranges\n\n        self.__computeScrollMax(zoom);\n      } else {\n        // Keep zoom when not defined\n        zoom = self.__zoomLevel;\n      }\n\n      if (!self.options.scrollingX) {\n        left = self.__scrollLeft;\n      } else {\n        if (self.options.paging) {\n          left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n        } else if (self.options.snapping) {\n          left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n        }\n      }\n\n      if (!self.options.scrollingY) {\n        top = self.__scrollTop;\n      } else {\n        if (self.options.paging) {\n          top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n        } else if (self.options.snapping) {\n          top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n        }\n      } // Limit for allowed ranges\n\n\n      left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n      top = Math.max(Math.min(self.__maxScrollTop, top), 0); // Don't animate when no change detected, still call publish to make sure\n      // that rendered position is really in-sync with internal data\n\n      if (left === self.__scrollLeft && top === self.__scrollTop) {\n        animate = false;\n      } // Publish new values\n\n\n      self.__publish(left, top, zoom, animate);\n    },\n\n    /**\r\n     * Scroll by the given offset\r\n     *\r\n     * @param left {Number ? 0} Scroll x-axis by given offset\r\n     * @param top {Number ? 0} Scroll x-axis by given offset\r\n     * @param animate {Boolean ? false} Whether to animate the given change\r\n     */\n    scrollBy: function (left, top, animate) {\n      var self = this;\n      var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;\n      var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n      self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n    },\n\n    /*\r\n    ---------------------------------------------------------------------------\r\n    \tEVENT CALLBACKS\r\n    ---------------------------------------------------------------------------\r\n    */\n\n    /**\r\n     * Mouse wheel handler for zooming support\r\n     */\n    doMouseZoom: function (wheelDelta, timeStamp, pageX, pageY) {\n      var self = this;\n      var change = wheelDelta > 0 ? 0.97 : 1.03;\n      return self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop);\n    },\n\n    /**\r\n     * Touch start handler for scrolling support\r\n     */\n    doTouchStart: function (touches, timeStamp) {\n      // Array-like check is enough here\n      if (touches.length == null) {\n        throw new Error(\"Invalid touch list: \" + touches);\n      }\n\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n\n      if (typeof timeStamp !== \"number\") {\n        throw new Error(\"Invalid timestamp value: \" + timeStamp);\n      }\n\n      var self = this; // Reset interruptedAnimation flag\n\n      self.__interruptedAnimation = true; // Stop deceleration\n\n      if (self.__isDecelerating) {\n        core.effect.Animate.stop(self.__isDecelerating);\n        self.__isDecelerating = false;\n        self.__interruptedAnimation = true;\n      } // Stop animation\n\n\n      if (self.__isAnimating) {\n        core.effect.Animate.stop(self.__isAnimating);\n        self.__isAnimating = false;\n        self.__interruptedAnimation = true;\n      } // Use center point when dealing with two fingers\n\n\n      var currentTouchLeft, currentTouchTop;\n      var isSingleTouch = touches.length === 1;\n\n      if (isSingleTouch) {\n        currentTouchLeft = touches[0].pageX;\n        currentTouchTop = touches[0].pageY;\n      } else {\n        currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      } // Store initial positions\n\n\n      self.__initialTouchLeft = currentTouchLeft;\n      self.__initialTouchTop = currentTouchTop; // Store current zoom level\n\n      self.__zoomLevelStart = self.__zoomLevel; // Store initial touch positions\n\n      self.__lastTouchLeft = currentTouchLeft;\n      self.__lastTouchTop = currentTouchTop; // Store initial move time stamp\n\n      self.__lastTouchMove = timeStamp; // Reset initial scale\n\n      self.__lastScale = 1; // Reset locking flags\n\n      self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n      self.__enableScrollY = !isSingleTouch && self.options.scrollingY; // Reset tracking flag\n\n      self.__isTracking = true; // Reset deceleration complete flag\n\n      self.__didDecelerationComplete = false; // Dragging starts directly with two fingers, otherwise lazy with an offset\n\n      self.__isDragging = !isSingleTouch; // Some features are disabled in multi touch scenarios\n\n      self.__isSingleTouch = isSingleTouch; // Clearing data structure\n\n      self.__positions = [];\n    },\n\n    /**\r\n     * Touch move handler for scrolling support\r\n     */\n    doTouchMove: function (touches, timeStamp, scale) {\n      // Array-like check is enough here\n      if (touches.length == null) {\n        throw new Error(\"Invalid touch list: \" + touches);\n      }\n\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n\n      if (typeof timeStamp !== \"number\") {\n        throw new Error(\"Invalid timestamp value: \" + timeStamp);\n      }\n\n      var self = this; // Ignore event when tracking is not enabled (event might be outside of element)\n\n      if (!self.__isTracking) {\n        return;\n      }\n\n      var currentTouchLeft, currentTouchTop; // Compute move based around of center of fingers\n\n      if (touches.length === 2) {\n        currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n        currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n      } else {\n        currentTouchLeft = touches[0].pageX;\n        currentTouchTop = touches[0].pageY;\n      }\n\n      var positions = self.__positions; // Are we already is dragging mode?\n\n      if (self.__isDragging) {\n        // Compute move distance\n        var moveX = currentTouchLeft - self.__lastTouchLeft;\n        var moveY = currentTouchTop - self.__lastTouchTop; // Read previous scroll position and zooming\n\n        var scrollLeft = self.__scrollLeft;\n        var scrollTop = self.__scrollTop;\n        var level = self.__zoomLevel; // Work with scaling\n\n        if (scale != null && self.options.zooming) {\n          var oldLevel = level; // Recompute level based on previous scale and new scale\n\n          level = level / self.__lastScale * scale; // Limit level according to configuration\n\n          level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom); // Only do further compution when change happened\n\n          if (oldLevel !== level) {\n            // Compute relative event position to container\n            var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n            var currentTouchTopRel = currentTouchTop - self.__clientTop; // Recompute left and top coordinates based on new zoom level\n\n            scrollLeft = (currentTouchLeftRel + scrollLeft) * level / oldLevel - currentTouchLeftRel;\n            scrollTop = (currentTouchTopRel + scrollTop) * level / oldLevel - currentTouchTopRel; // Recompute max scroll values\n\n            self.__computeScrollMax(level);\n          }\n        }\n\n        if (self.__enableScrollX) {\n          scrollLeft -= moveX * this.options.speedMultiplier;\n          var maxScrollLeft = self.__maxScrollLeft;\n\n          if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n            // Slow down on the edges\n            if (self.options.bouncing) {\n              scrollLeft += moveX / 2 * this.options.speedMultiplier;\n            } else if (scrollLeft > maxScrollLeft) {\n              scrollLeft = maxScrollLeft;\n            } else {\n              scrollLeft = 0;\n            }\n          }\n        } // Compute new vertical scroll position\n\n\n        if (self.__enableScrollY) {\n          scrollTop -= moveY * this.options.speedMultiplier;\n          var maxScrollTop = self.__maxScrollTop;\n\n          if (scrollTop > maxScrollTop || scrollTop < 0) {\n            // Slow down on the edges\n            if (self.options.bouncing) {\n              scrollTop += moveY / 2 * this.options.speedMultiplier; // Support pull-to-refresh (only when only y is scrollable)\n\n              if (!self.__enableScrollX && self.__refreshHeight != null) {\n                if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n                  self.__refreshActive = true;\n\n                  if (self.__refreshActivate) {\n                    self.__refreshActivate();\n                  }\n                } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {\n                  self.__refreshActive = false;\n\n                  if (self.__refreshDeactivate) {\n                    self.__refreshDeactivate();\n                  }\n                }\n              }\n            } else if (scrollTop > maxScrollTop) {\n              scrollTop = maxScrollTop;\n            } else {\n              scrollTop = 0;\n            }\n          }\n        } // Keep list from growing infinitely (holding min 10, max 20 measure points)\n\n\n        if (positions.length > 60) {\n          positions.splice(0, 30);\n        } // Track scroll movement for decleration\n\n\n        positions.push(scrollLeft, scrollTop, timeStamp); // Sync scroll position\n\n        self.__publish(scrollLeft, scrollTop, level); // Otherwise figure out whether we are switching into dragging mode now.\n\n      } else {\n        var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n        var minimumTrackingForDrag = 5;\n        var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n        var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n        self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n        self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n        positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n        self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);\n\n        if (self.__isDragging) {\n          self.__interruptedAnimation = false;\n        }\n      } // Update last touch positions and time stamp for next event\n\n\n      self.__lastTouchLeft = currentTouchLeft;\n      self.__lastTouchTop = currentTouchTop;\n      self.__lastTouchMove = timeStamp;\n      self.__lastScale = scale;\n    },\n\n    /**\r\n     * Touch end handler for scrolling support\r\n     */\n    doTouchEnd: function (timeStamp) {\n      if (timeStamp instanceof Date) {\n        timeStamp = timeStamp.valueOf();\n      }\n\n      if (typeof timeStamp !== \"number\") {\n        throw new Error(\"Invalid timestamp value: \" + timeStamp);\n      }\n\n      var self = this; // Ignore event when tracking is not enabled (no touchstart event on element)\n      // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n\n      if (!self.__isTracking) {\n        return;\n      } // Not touching anymore (when two finger hit the screen there are two touch end events)\n\n\n      self.__isTracking = false; // Be sure to reset the dragging flag now. Here we also detect whether\n      // the finger has moved fast enough to switch into a deceleration animation.\n\n      if (self.__isDragging) {\n        // Reset dragging flag\n        self.__isDragging = false; // Start deceleration\n        // Verify that the last move detected was in some relevant time frame\n\n        if (self.__isSingleTouch && self.options.animating && timeStamp - self.__lastTouchMove <= 100) {\n          // Then figure out what the scroll position was about 100ms ago\n          var positions = self.__positions;\n          var endPos = positions.length - 1;\n          var startPos = endPos; // Move pointer to position measured 100ms ago\n\n          for (var i = endPos; i > 0 && positions[i] > self.__lastTouchMove - 100; i -= 3) {\n            startPos = i;\n          } // If we haven't received consecutive touchmove events within a 100ms\n          // timeframe, attempt a best-effort based on the first position. This\n          // typically happens when an expensive operation occurs on the main\n          // thread during scrolling, such as image decoding.\n\n\n          if (startPos === endPos && positions.length > 5) {\n            startPos = 2;\n          } // If start and stop position is identical in a 100ms timeframe,\n          // we cannot compute any useful deceleration.\n\n\n          if (startPos !== endPos) {\n            // Compute relative movement between these two points\n            var timeOffset = positions[endPos] - positions[startPos];\n            var movedLeft = self.__scrollLeft - positions[startPos - 2];\n            var movedTop = self.__scrollTop - positions[startPos - 1]; // Based on 50ms compute the movement to apply for each render step\n\n            self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\n            self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60); // How much velocity is required to start the deceleration\n\n            var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1; // Verify that we have enough velocity to start deceleration\n\n            if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {\n              // Deactivate pull-to-refresh when decelerating\n              if (!self.__refreshActive) {\n                self.__startDeceleration(timeStamp);\n              }\n            }\n          } else {\n            self.options.scrollingComplete();\n          }\n        } else if (timeStamp - self.__lastTouchMove > 100) {\n          self.options.scrollingComplete();\n        }\n      } // If this was a slower move it is per default non decelerated, but this\n      // still means that we want snap back to the bounds which is done here.\n      // This is placed outside the condition above to improve edge case stability\n      // e.g. touchend fired without enabled dragging. This should normally do not\n      // have modified the scroll positions or even showed the scrollbars though.\n\n\n      if (!self.__isDecelerating) {\n        if (self.__refreshActive && self.__refreshStart) {\n          // Use publish instead of scrollTo to allow scrolling to out of boundary position\n          // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n          self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);\n\n          if (self.__refreshStart) {\n            self.__refreshStart();\n          }\n        } else {\n          if (self.__interruptedAnimation || self.__isDragging) {\n            self.options.scrollingComplete();\n          }\n\n          self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel); // Directly signalize deactivation (nothing todo on refresh?)\n\n          if (self.__refreshActive) {\n            self.__refreshActive = false;\n\n            if (self.__refreshDeactivate) {\n              self.__refreshDeactivate();\n            }\n          }\n        }\n      } // Fully cleanup list\n\n\n      self.__positions.length = 0;\n    },\n\n    /*\r\n    ---------------------------------------------------------------------------\r\n    \tPRIVATE API\r\n    ---------------------------------------------------------------------------\r\n    */\n\n    /**\r\n     * Applies the scroll position to the content element\r\n     *\r\n     * @param left {Number} Left scroll position\r\n     * @param top {Number} Top scroll position\r\n     * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\r\n     */\n    __publish: function (left, top, zoom, animate) {\n      var self = this; // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n\n      var wasAnimating = self.__isAnimating;\n\n      if (wasAnimating) {\n        core.effect.Animate.stop(wasAnimating);\n        self.__isAnimating = false;\n      }\n\n      if (animate && self.options.animating) {\n        // Keep scheduled positions for scrollBy/zoomBy functionality\n        self.__scheduledLeft = left;\n        self.__scheduledTop = top;\n        self.__scheduledZoom = zoom;\n        var oldLeft = self.__scrollLeft;\n        var oldTop = self.__scrollTop;\n        var oldZoom = self.__zoomLevel;\n        var diffLeft = left - oldLeft;\n        var diffTop = top - oldTop;\n        var diffZoom = zoom - oldZoom;\n\n        var step = function (percent, now, render) {\n          if (render) {\n            self.__scrollLeft = oldLeft + diffLeft * percent;\n            self.__scrollTop = oldTop + diffTop * percent;\n            self.__zoomLevel = oldZoom + diffZoom * percent; // Push values out\n\n            if (self.__callback) {\n              self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel);\n            }\n          }\n        };\n\n        var verify = function (id) {\n          return self.__isAnimating === id;\n        };\n\n        var completed = function (renderedFramesPerSecond, animationId, wasFinished) {\n          if (animationId === self.__isAnimating) {\n            self.__isAnimating = false;\n          }\n\n          if (self.__didDecelerationComplete || wasFinished) {\n            self.options.scrollingComplete();\n          }\n\n          if (self.options.zooming) {\n            self.__computeScrollMax();\n\n            if (self.__zoomComplete) {\n              self.__zoomComplete();\n\n              self.__zoomComplete = null;\n            }\n          }\n        }; // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n\n\n        self.__isAnimating = core.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);\n      } else {\n        self.__scheduledLeft = self.__scrollLeft = left;\n        self.__scheduledTop = self.__scrollTop = top;\n        self.__scheduledZoom = self.__zoomLevel = zoom; // Push values out\n\n        if (self.__callback) {\n          self.__callback(left, top, zoom);\n        } // Fix max scroll ranges\n\n\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n\n            self.__zoomComplete = null;\n          }\n        }\n      }\n    },\n\n    /**\r\n     * Recomputes scroll minimum values based on client dimensions and content dimensions.\r\n     */\n    __computeScrollMax: function (zoomLevel) {\n      var self = this;\n\n      if (zoomLevel == null) {\n        zoomLevel = self.__zoomLevel;\n      }\n\n      self.__maxScrollLeft = Math.max(self.__contentWidth * zoomLevel - self.__clientWidth, 0);\n      self.__maxScrollTop = Math.max(self.__contentHeight * zoomLevel - self.__clientHeight, 0);\n    },\n\n    /*\r\n    ---------------------------------------------------------------------------\r\n    \tANIMATION (DECELERATION) SUPPORT\r\n    ---------------------------------------------------------------------------\r\n    */\n\n    /**\r\n     * Called when a touch sequence end and the speed of the finger was high enough\r\n     * to switch into deceleration mode.\r\n     */\n    __startDeceleration: function (timeStamp) {\n      var self = this;\n\n      if (self.options.paging) {\n        var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);\n        var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);\n        var clientWidth = self.__clientWidth;\n        var clientHeight = self.__clientHeight; // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n        // Each page should have exactly the size of the client area.\n\n        self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;\n        self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;\n        self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;\n        self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;\n      } else {\n        self.__minDecelerationScrollLeft = 0;\n        self.__minDecelerationScrollTop = 0;\n        self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n        self.__maxDecelerationScrollTop = self.__maxScrollTop;\n      } // Wrap class method\n\n\n      var step = function (percent, now, render) {\n        self.__stepThroughDeceleration(render);\n      }; // How much velocity is required to keep the deceleration running\n\n\n      var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1; // Detect whether it's still worth to continue animating steps\n      // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n\n      var verify = function () {\n        var shouldContinue = Math.abs(self.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n\n        if (!shouldContinue) {\n          self.__didDecelerationComplete = true;\n        }\n\n        return shouldContinue;\n      };\n\n      var completed = function (renderedFramesPerSecond, animationId, wasFinished) {\n        self.__isDecelerating = false;\n\n        if (self.__didDecelerationComplete) {\n          self.options.scrollingComplete();\n        } // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n\n\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n      }; // Start animation and switch on flag\n\n\n      self.__isDecelerating = core.effect.Animate.start(step, verify, completed);\n    },\n\n    /**\r\n     * Called on every step of the animation\r\n     *\r\n     * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\r\n     */\n    __stepThroughDeceleration: function (render) {\n      var self = this; //\n      // COMPUTE NEXT SCROLL POSITION\n      //\n      // Add deceleration to scroll position\n\n      var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n      var scrollTop = self.__scrollTop + self.__decelerationVelocityY; //\n      // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n      //\n\n      if (!self.options.bouncing) {\n        var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);\n\n        if (scrollLeftFixed !== scrollLeft) {\n          scrollLeft = scrollLeftFixed;\n          self.__decelerationVelocityX = 0;\n        }\n\n        var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);\n\n        if (scrollTopFixed !== scrollTop) {\n          scrollTop = scrollTopFixed;\n          self.__decelerationVelocityY = 0;\n        }\n      } //\n      // UPDATE SCROLL POSITION\n      //\n\n\n      if (render) {\n        self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n      } else {\n        self.__scrollLeft = scrollLeft;\n        self.__scrollTop = scrollTop;\n      } //\n      // SLOW DOWN\n      //\n      // Slow down velocity on every iteration\n\n\n      if (!self.options.paging) {\n        // This is the factor applied to every iteration of the animation\n        // to slow down the process. This should emulate natural behavior where\n        // objects slow down when the initiator of the movement is removed\n        var frictionFactor = self.options.decelerationRate;\n        self.__decelerationVelocityX *= frictionFactor;\n        self.__decelerationVelocityY *= frictionFactor;\n      } //\n      // BOUNCING SUPPORT\n      //\n\n\n      if (self.options.bouncing) {\n        var scrollOutsideX = 0;\n        var scrollOutsideY = 0; // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n\n        var penetrationDeceleration = self.options.penetrationDeceleration;\n        var penetrationAcceleration = self.options.penetrationAcceleration; // Check limits\n\n        if (scrollLeft < self.__minDecelerationScrollLeft) {\n          scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n        } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n          scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n        }\n\n        if (scrollTop < self.__minDecelerationScrollTop) {\n          scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n        } else if (scrollTop > self.__maxDecelerationScrollTop) {\n          scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n        } // Slow down until slow enough, then flip back to snap position\n\n\n        if (scrollOutsideX !== 0) {\n          if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n            self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;\n          } else {\n            self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;\n          }\n        }\n\n        if (scrollOutsideY !== 0) {\n          if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n            self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;\n          } else {\n            self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;\n          }\n        }\n      }\n    }\n  }; // Copy over members to prototype\n\n  for (var key in members) {\n    Scroller.prototype[key] = members[key];\n  }\n\n  module.exports = Scroller;\n})();","map":{"version":3,"sources":["C:/Users/sonwonjae/react/react-tutorial/canvas-example/node_modules/scroller/src/Scroller.js"],"names":["core","require","Scroller","NOOP","callback","options","__callback","scrollingX","scrollingY","animating","animationDuration","bouncing","locking","paging","snapping","zooming","minZoom","maxZoom","speedMultiplier","scrollingComplete","decelerationRate","penetrationDeceleration","penetrationAcceleration","key","easeOutCubic","pos","Math","pow","easeInOutCubic","members","__isSingleTouch","__isTracking","__didDecelerationComplete","__isGesturing","__isDragging","__isDecelerating","__isAnimating","__clientLeft","__clientTop","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__snapWidth","__snapHeight","__refreshHeight","__refreshActive","__refreshActivate","__refreshDeactivate","__refreshStart","__zoomLevel","__scrollLeft","__scrollTop","__maxScrollLeft","__maxScrollTop","__scheduledLeft","__scheduledTop","__scheduledZoom","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__positions","__minDecelerationScrollLeft","__minDecelerationScrollTop","__maxDecelerationScrollLeft","__maxDecelerationScrollTop","__decelerationVelocityX","__decelerationVelocityY","setDimensions","clientWidth","clientHeight","contentWidth","contentHeight","self","__computeScrollMax","scrollTo","setPosition","left","top","setSnapSize","width","height","activatePullToRefresh","activateCallback","deactivateCallback","startCallback","triggerPullToRefresh","__publish","finishPullToRefresh","getValues","zoom","getScrollMax","zoomTo","level","animate","originLeft","originTop","Error","__zoomComplete","effect","Animate","stop","oldLevel","max","min","zoomBy","factor","round","scrollBy","startLeft","startTop","doMouseZoom","wheelDelta","timeStamp","pageX","pageY","change","doTouchStart","touches","length","Date","valueOf","__interruptedAnimation","currentTouchLeft","currentTouchTop","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastScale","__enableScrollX","__enableScrollY","doTouchMove","scale","positions","moveX","moveY","scrollLeft","scrollTop","currentTouchLeftRel","currentTouchTopRel","maxScrollLeft","maxScrollTop","splice","push","minimumTrackingForScroll","minimumTrackingForDrag","distanceX","distanceY","doTouchEnd","endPos","startPos","i","timeOffset","movedLeft","movedTop","minVelocityToStartDeceleration","__startDeceleration","wasAnimating","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","step","percent","now","render","verify","id","completed","renderedFramesPerSecond","animationId","wasFinished","start","zoomLevel","floor","ceil","__stepThroughDeceleration","minVelocityToKeepDecelerating","shouldContinue","scrollLeftFixed","scrollTopFixed","frictionFactor","scrollOutsideX","scrollOutsideY","prototype","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * Scroller\r\n * http://github.com/zynga/scroller\r\n *\r\n * Copyright 2011, Zynga Inc.\r\n * Licensed under the MIT License.\r\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\r\n *\r\n * Based on the work of: Unify Project (unify-project.org)\r\n * http://unify-project.org\r\n * Copyright 2011, Deutsche Telekom AG\r\n * License: MIT + Apache (V2)\r\n */\r\n\r\nvar core = require('./Animate');\r\nvar Scroller;\r\n\r\n(function() {\r\n\tvar NOOP = function(){};\r\n\r\n\t/**\r\n\t * A pure logic 'component' for 'virtual' scrolling/zooming.\r\n\t */\r\n\tScroller = function(callback, options) {\r\n\r\n\t\tthis.__callback = callback;\r\n\r\n\t\tthis.options = {\r\n\r\n\t\t\t/** Enable scrolling on x-axis */\r\n\t\t\tscrollingX: true,\r\n\r\n\t\t\t/** Enable scrolling on y-axis */\r\n\t\t\tscrollingY: true,\r\n\r\n\t\t\t/** Enable animations for deceleration, snap back, zooming and scrolling */\r\n\t\t\tanimating: true,\r\n\r\n\t\t\t/** duration for animations triggered by scrollTo/zoomTo */\r\n\t\t\tanimationDuration: 250,\r\n\r\n\t\t\t/** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\r\n\t\t\tbouncing: true,\r\n\r\n\t\t\t/** Enable locking to the main axis if user moves only slightly on one of them at start */\r\n\t\t\tlocking: true,\r\n\r\n\t\t\t/** Enable pagination mode (switching between full page content panes) */\r\n\t\t\tpaging: false,\r\n\r\n\t\t\t/** Enable snapping of content to a configured pixel grid */\r\n\t\t\tsnapping: false,\r\n\r\n\t\t\t/** Enable zooming of content via API, fingers and mouse wheel */\r\n\t\t\tzooming: false,\r\n\r\n\t\t\t/** Minimum zoom level */\r\n\t\t\tminZoom: 0.5,\r\n\r\n\t\t\t/** Maximum zoom level */\r\n\t\t\tmaxZoom: 3,\r\n\r\n\t\t\t/** Multiply or decrease scrolling speed **/\r\n\t\t\tspeedMultiplier: 1,\r\n\r\n\t\t\t/** Callback that is fired on the later of touch end or deceleration end,\r\n\t\t\t\tprovided that another scrolling action has not begun. Used to know\r\n\t\t\t\twhen to fade out a scrollbar. */\r\n\t\t\tscrollingComplete: NOOP,\r\n\r\n\t\t\t/** Increase or decrease the amount of friction applied to deceleration **/\r\n\t\t\tdecelerationRate: 0.95,\r\n\t\t\t\r\n\t\t\t/** This configures the amount of change applied to deceleration when reaching boundaries  **/\r\n            penetrationDeceleration : 0.03,\r\n\r\n            /** This configures the amount of change applied to acceleration when reaching boundaries  **/\r\n            penetrationAcceleration : 0.08\r\n\r\n\t\t};\r\n\r\n\t\tfor (var key in options) {\r\n\t\t\tthis.options[key] = options[key];\r\n\t\t}\r\n\r\n\t};\r\n\r\n\r\n\t// Easing Equations (c) 2003 Robert Penner, all rights reserved.\r\n\t// Open source under the BSD License.\r\n\r\n\t/**\r\n\t * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\r\n\t**/\r\n\tvar easeOutCubic = function(pos) {\r\n\t\treturn (Math.pow((pos - 1), 3) + 1);\r\n\t};\r\n\r\n\t/**\r\n\t * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\r\n\t**/\r\n\tvar easeInOutCubic = function(pos) {\r\n\t\tif ((pos /= 0.5) < 1) {\r\n\t\t\treturn 0.5 * Math.pow(pos, 3);\r\n\t\t}\r\n\r\n\t\treturn 0.5 * (Math.pow((pos - 2), 3) + 2);\r\n\t};\r\n\r\n\r\n\tvar members = {\r\n\r\n\t\t/*\r\n\t\t---------------------------------------------------------------------------\r\n\t\t\tINTERNAL FIELDS :: STATUS\r\n\t\t---------------------------------------------------------------------------\r\n\t\t*/\r\n\r\n\t\t/** {Boolean} Whether only a single finger is used in touch handling */\r\n\t\t__isSingleTouch: false,\r\n\r\n\t\t/** {Boolean} Whether a touch event sequence is in progress */\r\n\t\t__isTracking: false,\r\n\r\n\t\t/** {Boolean} Whether a deceleration animation went to completion. */\r\n\t\t__didDecelerationComplete: false,\r\n\r\n\t\t/**\r\n\t\t * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\r\n\t\t * a gesturestart event happens. This has higher priority than dragging.\r\n\t\t */\r\n\t\t__isGesturing: false,\r\n\r\n\t\t/**\r\n\t\t * {Boolean} Whether the user has moved by such a distance that we have enabled\r\n\t\t * dragging mode. Hint: It's only enabled after some pixels of movement to\r\n\t\t * not interrupt with clicks etc.\r\n\t\t */\r\n\t\t__isDragging: false,\r\n\r\n\t\t/**\r\n\t\t * {Boolean} Not touching and dragging anymore, and smoothly animating the\r\n\t\t * touch sequence using deceleration.\r\n\t\t */\r\n\t\t__isDecelerating: false,\r\n\r\n\t\t/**\r\n\t\t * {Boolean} Smoothly animating the currently configured change\r\n\t\t */\r\n\t\t__isAnimating: false,\r\n\r\n\r\n\r\n\t\t/*\r\n\t\t---------------------------------------------------------------------------\r\n\t\t\tINTERNAL FIELDS :: DIMENSIONS\r\n\t\t---------------------------------------------------------------------------\r\n\t\t*/\r\n\r\n\t\t/** {Integer} Available outer left position (from document perspective) */\r\n\t\t__clientLeft: 0,\r\n\r\n\t\t/** {Integer} Available outer top position (from document perspective) */\r\n\t\t__clientTop: 0,\r\n\r\n\t\t/** {Integer} Available outer width */\r\n\t\t__clientWidth: 0,\r\n\r\n\t\t/** {Integer} Available outer height */\r\n\t\t__clientHeight: 0,\r\n\r\n\t\t/** {Integer} Outer width of content */\r\n\t\t__contentWidth: 0,\r\n\r\n\t\t/** {Integer} Outer height of content */\r\n\t\t__contentHeight: 0,\r\n\r\n\t\t/** {Integer} Snapping width for content */\r\n\t\t__snapWidth: 100,\r\n\r\n\t\t/** {Integer} Snapping height for content */\r\n\t\t__snapHeight: 100,\r\n\r\n\t\t/** {Integer} Height to assign to refresh area */\r\n\t\t__refreshHeight: null,\r\n\r\n\t\t/** {Boolean} Whether the refresh process is enabled when the event is released now */\r\n\t\t__refreshActive: false,\r\n\r\n\t\t/** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\r\n\t\t__refreshActivate: null,\r\n\r\n\t\t/** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\r\n\t\t__refreshDeactivate: null,\r\n\r\n\t\t/** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\r\n\t\t__refreshStart: null,\r\n\r\n\t\t/** {Number} Zoom level */\r\n\t\t__zoomLevel: 1,\r\n\r\n\t\t/** {Number} Scroll position on x-axis */\r\n\t\t__scrollLeft: 0,\r\n\r\n\t\t/** {Number} Scroll position on y-axis */\r\n\t\t__scrollTop: 0,\r\n\r\n\t\t/** {Integer} Maximum allowed scroll position on x-axis */\r\n\t\t__maxScrollLeft: 0,\r\n\r\n\t\t/** {Integer} Maximum allowed scroll position on y-axis */\r\n\t\t__maxScrollTop: 0,\r\n\r\n\t\t/* {Number} Scheduled left position (final position when animating) */\r\n\t\t__scheduledLeft: 0,\r\n\r\n\t\t/* {Number} Scheduled top position (final position when animating) */\r\n\t\t__scheduledTop: 0,\r\n\r\n\t\t/* {Number} Scheduled zoom level (final scale when animating) */\r\n\t\t__scheduledZoom: 0,\r\n\r\n\r\n\r\n\t\t/*\r\n\t\t---------------------------------------------------------------------------\r\n\t\t\tINTERNAL FIELDS :: LAST POSITIONS\r\n\t\t---------------------------------------------------------------------------\r\n\t\t*/\r\n\r\n\t\t/** {Number} Left position of finger at start */\r\n\t\t__lastTouchLeft: null,\r\n\r\n\t\t/** {Number} Top position of finger at start */\r\n\t\t__lastTouchTop: null,\r\n\r\n\t\t/** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\r\n\t\t__lastTouchMove: null,\r\n\r\n\t\t/** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\r\n\t\t__positions: null,\r\n\r\n\r\n\r\n\t\t/*\r\n\t\t---------------------------------------------------------------------------\r\n\t\t\tINTERNAL FIELDS :: DECELERATION SUPPORT\r\n\t\t---------------------------------------------------------------------------\r\n\t\t*/\r\n\r\n\t\t/** {Integer} Minimum left scroll position during deceleration */\r\n\t\t__minDecelerationScrollLeft: null,\r\n\r\n\t\t/** {Integer} Minimum top scroll position during deceleration */\r\n\t\t__minDecelerationScrollTop: null,\r\n\r\n\t\t/** {Integer} Maximum left scroll position during deceleration */\r\n\t\t__maxDecelerationScrollLeft: null,\r\n\r\n\t\t/** {Integer} Maximum top scroll position during deceleration */\r\n\t\t__maxDecelerationScrollTop: null,\r\n\r\n\t\t/** {Number} Current factor to modify horizontal scroll position with on every step */\r\n\t\t__decelerationVelocityX: null,\r\n\r\n\t\t/** {Number} Current factor to modify vertical scroll position with on every step */\r\n\t\t__decelerationVelocityY: null,\r\n\r\n\r\n\r\n\t\t/*\r\n\t\t---------------------------------------------------------------------------\r\n\t\t\tPUBLIC API\r\n\t\t---------------------------------------------------------------------------\r\n\t\t*/\r\n\r\n\t\t/**\r\n\t\t * Configures the dimensions of the client (outer) and content (inner) elements.\r\n\t\t * Requires the available space for the outer element and the outer size of the inner element.\r\n\t\t * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\r\n\t\t *\r\n\t\t * @param clientWidth {Integer ? null} Inner width of outer element\r\n\t\t * @param clientHeight {Integer ? null} Inner height of outer element\r\n\t\t * @param contentWidth {Integer ? null} Outer width of inner element\r\n\t\t * @param contentHeight {Integer ? null} Outer height of inner element\r\n\t\t */\r\n\t\tsetDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\t// Only update values which are defined\r\n\t\t\tif (clientWidth === +clientWidth) {\r\n\t\t\t\tself.__clientWidth = clientWidth;\r\n\t\t\t}\r\n\r\n\t\t\tif (clientHeight === +clientHeight) {\r\n\t\t\t\tself.__clientHeight = clientHeight;\r\n\t\t\t}\r\n\r\n\t\t\tif (contentWidth === +contentWidth) {\r\n\t\t\t\tself.__contentWidth = contentWidth;\r\n\t\t\t}\r\n\r\n\t\t\tif (contentHeight === +contentHeight) {\r\n\t\t\t\tself.__contentHeight = contentHeight;\r\n\t\t\t}\r\n\r\n\t\t\t// Refresh maximums\r\n\t\t\tself.__computeScrollMax();\r\n\r\n\t\t\t// Refresh scroll position\r\n\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Sets the client coordinates in relation to the document.\r\n\t\t *\r\n\t\t * @param left {Integer ? 0} Left position of outer element\r\n\t\t * @param top {Integer ? 0} Top position of outer element\r\n\t\t */\r\n\t\tsetPosition: function(left, top) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tself.__clientLeft = left || 0;\r\n\t\t\tself.__clientTop = top || 0;\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Configures the snapping (when snapping is active)\r\n\t\t *\r\n\t\t * @param width {Integer} Snapping width\r\n\t\t * @param height {Integer} Snapping height\r\n\t\t */\r\n\t\tsetSnapSize: function(width, height) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tself.__snapWidth = width;\r\n\t\t\tself.__snapHeight = height;\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\r\n\t\t * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\r\n\t\t * the official Twitter client.\r\n\t\t *\r\n\t\t * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\r\n\t\t * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\r\n\t\t * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\r\n\t\t * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\r\n\t\t */\r\n\t\tactivatePullToRefresh: function(height, activateCallback, deactivateCallback, startCallback) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tself.__refreshHeight = height;\r\n\t\t\tself.__refreshActivate = activateCallback;\r\n\t\t\tself.__refreshDeactivate = deactivateCallback;\r\n\t\t\tself.__refreshStart = startCallback;\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Starts pull-to-refresh manually.\r\n\t\t */\r\n\t\ttriggerPullToRefresh: function() {\r\n\t\t\t// Use publish instead of scrollTo to allow scrolling to out of boundary position\r\n\t\t\t// We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\r\n\t\t\tthis.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);\r\n\r\n\t\t\tif (this.__refreshStart) {\r\n\t\t\t\tthis.__refreshStart();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Signalizes that pull-to-refresh is finished.\r\n\t\t */\r\n\t\tfinishPullToRefresh: function() {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tself.__refreshActive = false;\r\n\t\t\tif (self.__refreshDeactivate) {\r\n\t\t\t\tself.__refreshDeactivate();\r\n\t\t\t}\r\n\r\n\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Returns the scroll position and zooming values\r\n\t\t *\r\n\t\t * @return {Map} `left` and `top` scroll position and `zoom` level\r\n\t\t */\r\n\t\tgetValues: function() {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tleft: self.__scrollLeft,\r\n\t\t\t\ttop: self.__scrollTop,\r\n\t\t\t\tzoom: self.__zoomLevel\r\n\t\t\t};\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Returns the maximum scroll values\r\n\t\t *\r\n\t\t * @return {Map} `left` and `top` maximum scroll values\r\n\t\t */\r\n\t\tgetScrollMax: function() {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tleft: self.__maxScrollLeft,\r\n\t\t\t\ttop: self.__maxScrollTop\r\n\t\t\t};\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Zooms to the given level. Supports optional animation. Zooms\r\n\t\t * the center when no coordinates are given.\r\n\t\t *\r\n\t\t * @param level {Number} Level to zoom to\r\n\t\t * @param animate {Boolean ? false} Whether to use animation\r\n\t\t * @param originLeft {Number ? null} Zoom in at given left coordinate\r\n\t\t * @param originTop {Number ? null} Zoom in at given top coordinate\r\n\t\t * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\r\n\t\t */\r\n\t\tzoomTo: function(level, animate, originLeft, originTop, callback) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tif (!self.options.zooming) {\r\n\t\t\t\tthrow new Error(\"Zooming is not enabled!\");\r\n\t\t\t}\r\n\r\n\t\t\t// Add callback if exists\r\n\t\t\tif(callback) {\r\n\t\t\t\tself.__zoomComplete = callback;\r\n\t\t\t}\r\n\r\n\t\t\t// Stop deceleration\r\n\t\t\tif (self.__isDecelerating) {\r\n\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\r\n\t\t\t\tself.__isDecelerating = false;\r\n\t\t\t}\r\n\r\n\t\t\tvar oldLevel = self.__zoomLevel;\r\n\r\n\t\t\t// Normalize input origin to center of viewport if not defined\r\n\t\t\tif (originLeft == null) {\r\n\t\t\t\toriginLeft = self.__clientWidth / 2;\r\n\t\t\t}\r\n\r\n\t\t\tif (originTop == null) {\r\n\t\t\t\toriginTop = self.__clientHeight / 2;\r\n\t\t\t}\r\n\r\n\t\t\t// Limit level according to configuration\r\n\t\t\tlevel = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\r\n\r\n\t\t\t// Recompute maximum values while temporary tweaking maximum scroll ranges\r\n\t\t\tself.__computeScrollMax(level);\r\n\r\n\t\t\t// Recompute left and top coordinates based on new zoom level\r\n\t\t\tvar left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;\r\n\t\t\tvar top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;\r\n\r\n\t\t\t// Limit x-axis\r\n\t\t\tif (left > self.__maxScrollLeft) {\r\n\t\t\t\tleft = self.__maxScrollLeft;\r\n\t\t\t} else if (left < 0) {\r\n\t\t\t\tleft = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Limit y-axis\r\n\t\t\tif (top > self.__maxScrollTop) {\r\n\t\t\t\ttop = self.__maxScrollTop;\r\n\t\t\t} else if (top < 0) {\r\n\t\t\t\ttop = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Push values out\r\n\t\t\tself.__publish(left, top, level, animate);\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Zooms the content by the given factor.\r\n\t\t *\r\n\t\t * @param factor {Number} Zoom by given factor\r\n\t\t * @param animate {Boolean ? false} Whether to use animation\r\n\t\t * @param originLeft {Number ? 0} Zoom in at given left coordinate\r\n\t\t * @param originTop {Number ? 0} Zoom in at given top coordinate\r\n\t\t * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\r\n\t\t */\r\n\t\tzoomBy: function(factor, animate, originLeft, originTop, callback) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tself.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop, callback);\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Scrolls to the given position. Respect limitations and snapping automatically.\r\n\t\t *\r\n\t\t * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\r\n\t\t * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\r\n\t\t * @param animate {Boolean?false} Whether the scrolling should happen using an animation\r\n\t\t * @param zoom {Number?null} Zoom level to go to\r\n\t\t */\r\n\t\tscrollTo: function(left, top, animate, zoom) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\t// Stop deceleration\r\n\t\t\tif (self.__isDecelerating) {\r\n\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\r\n\t\t\t\tself.__isDecelerating = false;\r\n\t\t\t}\r\n\r\n\t\t\t// Correct coordinates based on new zoom level\r\n\t\t\tif (zoom != null && zoom !== self.__zoomLevel) {\r\n\r\n\t\t\t\tif (!self.options.zooming) {\r\n\t\t\t\t\tthrow new Error(\"Zooming is not enabled!\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tleft *= zoom;\r\n\t\t\t\ttop *= zoom;\r\n\r\n\t\t\t\t// Recompute maximum values while temporary tweaking maximum scroll ranges\r\n\t\t\t\tself.__computeScrollMax(zoom);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Keep zoom when not defined\r\n\t\t\t\tzoom = self.__zoomLevel;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (!self.options.scrollingX) {\r\n\r\n\t\t\t\tleft = self.__scrollLeft;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (self.options.paging) {\r\n\t\t\t\t\tleft = Math.round(left / self.__clientWidth) * self.__clientWidth;\r\n\t\t\t\t} else if (self.options.snapping) {\r\n\t\t\t\t\tleft = Math.round(left / self.__snapWidth) * self.__snapWidth;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (!self.options.scrollingY) {\r\n\r\n\t\t\t\ttop = self.__scrollTop;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (self.options.paging) {\r\n\t\t\t\t\ttop = Math.round(top / self.__clientHeight) * self.__clientHeight;\r\n\t\t\t\t} else if (self.options.snapping) {\r\n\t\t\t\t\ttop = Math.round(top / self.__snapHeight) * self.__snapHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Limit for allowed ranges\r\n\t\t\tleft = Math.max(Math.min(self.__maxScrollLeft, left), 0);\r\n\t\t\ttop = Math.max(Math.min(self.__maxScrollTop, top), 0);\r\n\r\n\t\t\t// Don't animate when no change detected, still call publish to make sure\r\n\t\t\t// that rendered position is really in-sync with internal data\r\n\t\t\tif (left === self.__scrollLeft && top === self.__scrollTop) {\r\n\t\t\t\tanimate = false;\r\n\t\t\t}\r\n\r\n\t\t\t// Publish new values\r\n\t\t\tself.__publish(left, top, zoom, animate);\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Scroll by the given offset\r\n\t\t *\r\n\t\t * @param left {Number ? 0} Scroll x-axis by given offset\r\n\t\t * @param top {Number ? 0} Scroll x-axis by given offset\r\n\t\t * @param animate {Boolean ? false} Whether to animate the given change\r\n\t\t */\r\n\t\tscrollBy: function(left, top, animate) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tvar startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;\r\n\t\t\tvar startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\r\n\r\n\t\t\tself.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\r\n\r\n\t\t},\r\n\r\n\r\n\r\n\t\t/*\r\n\t\t---------------------------------------------------------------------------\r\n\t\t\tEVENT CALLBACKS\r\n\t\t---------------------------------------------------------------------------\r\n\t\t*/\r\n\r\n\t\t/**\r\n\t\t * Mouse wheel handler for zooming support\r\n\t\t */\r\n\t\tdoMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tvar change = wheelDelta > 0 ? 0.97 : 1.03;\r\n\r\n\t\t\treturn self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop);\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Touch start handler for scrolling support\r\n\t\t */\r\n\t\tdoTouchStart: function(touches, timeStamp) {\r\n\r\n\t\t\t// Array-like check is enough here\r\n\t\t\tif (touches.length == null) {\r\n\t\t\t\tthrow new Error(\"Invalid touch list: \" + touches);\r\n\t\t\t}\r\n\r\n\t\t\tif (timeStamp instanceof Date) {\r\n\t\t\t\ttimeStamp = timeStamp.valueOf();\r\n\t\t\t}\r\n\t\t\tif (typeof timeStamp !== \"number\") {\r\n\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\r\n\t\t\t}\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\t// Reset interruptedAnimation flag\r\n\t\t\tself.__interruptedAnimation = true;\r\n\r\n\t\t\t// Stop deceleration\r\n\t\t\tif (self.__isDecelerating) {\r\n\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\r\n\t\t\t\tself.__isDecelerating = false;\r\n\t\t\t\tself.__interruptedAnimation = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Stop animation\r\n\t\t\tif (self.__isAnimating) {\r\n\t\t\t\tcore.effect.Animate.stop(self.__isAnimating);\r\n\t\t\t\tself.__isAnimating = false;\r\n\t\t\t\tself.__interruptedAnimation = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Use center point when dealing with two fingers\r\n\t\t\tvar currentTouchLeft, currentTouchTop;\r\n\t\t\tvar isSingleTouch = touches.length === 1;\r\n\t\t\tif (isSingleTouch) {\r\n\t\t\t\tcurrentTouchLeft = touches[0].pageX;\r\n\t\t\t\tcurrentTouchTop = touches[0].pageY;\r\n\t\t\t} else {\r\n\t\t\t\tcurrentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\r\n\t\t\t\tcurrentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\r\n\t\t\t}\r\n\r\n\t\t\t// Store initial positions\r\n\t\t\tself.__initialTouchLeft = currentTouchLeft;\r\n\t\t\tself.__initialTouchTop = currentTouchTop;\r\n\r\n\t\t\t// Store current zoom level\r\n\t\t\tself.__zoomLevelStart = self.__zoomLevel;\r\n\r\n\t\t\t// Store initial touch positions\r\n\t\t\tself.__lastTouchLeft = currentTouchLeft;\r\n\t\t\tself.__lastTouchTop = currentTouchTop;\r\n\r\n\t\t\t// Store initial move time stamp\r\n\t\t\tself.__lastTouchMove = timeStamp;\r\n\r\n\t\t\t// Reset initial scale\r\n\t\t\tself.__lastScale = 1;\r\n\r\n\t\t\t// Reset locking flags\r\n\t\t\tself.__enableScrollX = !isSingleTouch && self.options.scrollingX;\r\n\t\t\tself.__enableScrollY = !isSingleTouch && self.options.scrollingY;\r\n\r\n\t\t\t// Reset tracking flag\r\n\t\t\tself.__isTracking = true;\r\n\r\n\t\t\t// Reset deceleration complete flag\r\n\t\t\tself.__didDecelerationComplete = false;\r\n\r\n\t\t\t// Dragging starts directly with two fingers, otherwise lazy with an offset\r\n\t\t\tself.__isDragging = !isSingleTouch;\r\n\r\n\t\t\t// Some features are disabled in multi touch scenarios\r\n\t\t\tself.__isSingleTouch = isSingleTouch;\r\n\r\n\t\t\t// Clearing data structure\r\n\t\t\tself.__positions = [];\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Touch move handler for scrolling support\r\n\t\t */\r\n\t\tdoTouchMove: function(touches, timeStamp, scale) {\r\n\r\n\t\t\t// Array-like check is enough here\r\n\t\t\tif (touches.length == null) {\r\n\t\t\t\tthrow new Error(\"Invalid touch list: \" + touches);\r\n\t\t\t}\r\n\r\n\t\t\tif (timeStamp instanceof Date) {\r\n\t\t\t\ttimeStamp = timeStamp.valueOf();\r\n\t\t\t}\r\n\t\t\tif (typeof timeStamp !== \"number\") {\r\n\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\r\n\t\t\t}\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\t// Ignore event when tracking is not enabled (event might be outside of element)\r\n\t\t\tif (!self.__isTracking) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tvar currentTouchLeft, currentTouchTop;\r\n\r\n\t\t\t// Compute move based around of center of fingers\r\n\t\t\tif (touches.length === 2) {\r\n\t\t\t\tcurrentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\r\n\t\t\t\tcurrentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\r\n\t\t\t} else {\r\n\t\t\t\tcurrentTouchLeft = touches[0].pageX;\r\n\t\t\t\tcurrentTouchTop = touches[0].pageY;\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = self.__positions;\r\n\r\n\t\t\t// Are we already is dragging mode?\r\n\t\t\tif (self.__isDragging) {\r\n\r\n\t\t\t\t// Compute move distance\r\n\t\t\t\tvar moveX = currentTouchLeft - self.__lastTouchLeft;\r\n\t\t\t\tvar moveY = currentTouchTop - self.__lastTouchTop;\r\n\r\n\t\t\t\t// Read previous scroll position and zooming\r\n\t\t\t\tvar scrollLeft = self.__scrollLeft;\r\n\t\t\t\tvar scrollTop = self.__scrollTop;\r\n\t\t\t\tvar level = self.__zoomLevel;\r\n\r\n\t\t\t\t// Work with scaling\r\n\t\t\t\tif (scale != null && self.options.zooming) {\r\n\r\n\t\t\t\t\tvar oldLevel = level;\r\n\r\n\t\t\t\t\t// Recompute level based on previous scale and new scale\r\n\t\t\t\t\tlevel = level / self.__lastScale * scale;\r\n\r\n\t\t\t\t\t// Limit level according to configuration\r\n\t\t\t\t\tlevel = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\r\n\r\n\t\t\t\t\t// Only do further compution when change happened\r\n\t\t\t\t\tif (oldLevel !== level) {\r\n\r\n\t\t\t\t\t\t// Compute relative event position to container\r\n\t\t\t\t\t\tvar currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\r\n\t\t\t\t\t\tvar currentTouchTopRel = currentTouchTop - self.__clientTop;\r\n\r\n\t\t\t\t\t\t// Recompute left and top coordinates based on new zoom level\r\n\t\t\t\t\t\tscrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;\r\n\t\t\t\t\t\tscrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;\r\n\r\n\t\t\t\t\t\t// Recompute max scroll values\r\n\t\t\t\t\t\tself.__computeScrollMax(level);\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (self.__enableScrollX) {\r\n\r\n\t\t\t\t\tscrollLeft -= moveX * this.options.speedMultiplier;\r\n\t\t\t\t\tvar maxScrollLeft = self.__maxScrollLeft;\r\n\r\n\t\t\t\t\tif (scrollLeft > maxScrollLeft || scrollLeft < 0) {\r\n\r\n\t\t\t\t\t\t// Slow down on the edges\r\n\t\t\t\t\t\tif (self.options.bouncing) {\r\n\r\n\t\t\t\t\t\t\tscrollLeft += (moveX / 2  * this.options.speedMultiplier);\r\n\r\n\t\t\t\t\t\t} else if (scrollLeft > maxScrollLeft) {\r\n\r\n\t\t\t\t\t\t\tscrollLeft = maxScrollLeft;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tscrollLeft = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Compute new vertical scroll position\r\n\t\t\t\tif (self.__enableScrollY) {\r\n\r\n\t\t\t\t\tscrollTop -= moveY * this.options.speedMultiplier;\r\n\t\t\t\t\tvar maxScrollTop = self.__maxScrollTop;\r\n\r\n\t\t\t\t\tif (scrollTop > maxScrollTop || scrollTop < 0) {\r\n\r\n\t\t\t\t\t\t// Slow down on the edges\r\n\t\t\t\t\t\tif (self.options.bouncing) {\r\n\r\n\t\t\t\t\t\t\tscrollTop += (moveY / 2 * this.options.speedMultiplier);\r\n\r\n\t\t\t\t\t\t\t// Support pull-to-refresh (only when only y is scrollable)\r\n\t\t\t\t\t\t\tif (!self.__enableScrollX && self.__refreshHeight != null) {\r\n\r\n\t\t\t\t\t\t\t\tif (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\r\n\r\n\t\t\t\t\t\t\t\t\tself.__refreshActive = true;\r\n\t\t\t\t\t\t\t\t\tif (self.__refreshActivate) {\r\n\t\t\t\t\t\t\t\t\t\tself.__refreshActivate();\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t} else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {\r\n\r\n\t\t\t\t\t\t\t\t\tself.__refreshActive = false;\r\n\t\t\t\t\t\t\t\t\tif (self.__refreshDeactivate) {\r\n\t\t\t\t\t\t\t\t\t\tself.__refreshDeactivate();\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if (scrollTop > maxScrollTop) {\r\n\r\n\t\t\t\t\t\t\tscrollTop = maxScrollTop;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tscrollTop = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Keep list from growing infinitely (holding min 10, max 20 measure points)\r\n\t\t\t\tif (positions.length > 60) {\r\n\t\t\t\t\tpositions.splice(0, 30);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Track scroll movement for decleration\r\n\t\t\t\tpositions.push(scrollLeft, scrollTop, timeStamp);\r\n\r\n\t\t\t\t// Sync scroll position\r\n\t\t\t\tself.__publish(scrollLeft, scrollTop, level);\r\n\r\n\t\t\t// Otherwise figure out whether we are switching into dragging mode now.\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar minimumTrackingForScroll = self.options.locking ? 3 : 0;\r\n\t\t\t\tvar minimumTrackingForDrag = 5;\r\n\r\n\t\t\t\tvar distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\r\n\t\t\t\tvar distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\r\n\r\n\t\t\t\tself.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;\r\n\t\t\t\tself.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;\r\n\r\n\t\t\t\tpositions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\r\n\r\n\t\t\t\tself.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);\r\n\t\t\t\tif (self.__isDragging) {\r\n\t\t\t\t\tself.__interruptedAnimation = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Update last touch positions and time stamp for next event\r\n\t\t\tself.__lastTouchLeft = currentTouchLeft;\r\n\t\t\tself.__lastTouchTop = currentTouchTop;\r\n\t\t\tself.__lastTouchMove = timeStamp;\r\n\t\t\tself.__lastScale = scale;\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Touch end handler for scrolling support\r\n\t\t */\r\n\t\tdoTouchEnd: function(timeStamp) {\r\n\r\n\t\t\tif (timeStamp instanceof Date) {\r\n\t\t\t\ttimeStamp = timeStamp.valueOf();\r\n\t\t\t}\r\n\t\t\tif (typeof timeStamp !== \"number\") {\r\n\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\r\n\t\t\t}\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\t// Ignore event when tracking is not enabled (no touchstart event on element)\r\n\t\t\t// This is required as this listener ('touchmove') sits on the document and not on the element itself.\r\n\t\t\tif (!self.__isTracking) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Not touching anymore (when two finger hit the screen there are two touch end events)\r\n\t\t\tself.__isTracking = false;\r\n\r\n\t\t\t// Be sure to reset the dragging flag now. Here we also detect whether\r\n\t\t\t// the finger has moved fast enough to switch into a deceleration animation.\r\n\t\t\tif (self.__isDragging) {\r\n\r\n\t\t\t\t// Reset dragging flag\r\n\t\t\t\tself.__isDragging = false;\r\n\r\n\t\t\t\t// Start deceleration\r\n\t\t\t\t// Verify that the last move detected was in some relevant time frame\r\n\t\t\t\tif (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {\r\n\r\n\t\t\t\t\t// Then figure out what the scroll position was about 100ms ago\r\n\t\t\t\t\tvar positions = self.__positions;\r\n\t\t\t\t\tvar endPos = positions.length - 1;\r\n\t\t\t\t\tvar startPos = endPos;\r\n\r\n\t\t\t\t\t// Move pointer to position measured 100ms ago\r\n\t\t\t\t\tfor (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {\r\n\t\t\t\t\t\tstartPos = i;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// If we haven't received consecutive touchmove events within a 100ms\r\n\t\t\t\t\t// timeframe, attempt a best-effort based on the first position. This\r\n\t\t\t\t\t// typically happens when an expensive operation occurs on the main\r\n\t\t\t\t\t// thread during scrolling, such as image decoding.\r\n\t\t\t\t\tif (startPos === endPos && positions.length > 5) {\r\n\t\t\t\t\t\tstartPos = 2;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// If start and stop position is identical in a 100ms timeframe,\r\n\t\t\t\t\t// we cannot compute any useful deceleration.\r\n\t\t\t\t\tif (startPos !== endPos) {\r\n\r\n\t\t\t\t\t\t// Compute relative movement between these two points\r\n\t\t\t\t\t\tvar timeOffset = positions[endPos] - positions[startPos];\r\n\t\t\t\t\t\tvar movedLeft = self.__scrollLeft - positions[startPos - 2];\r\n\t\t\t\t\t\tvar movedTop = self.__scrollTop - positions[startPos - 1];\r\n\r\n\t\t\t\t\t\t// Based on 50ms compute the movement to apply for each render step\r\n\t\t\t\t\t\tself.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\r\n\t\t\t\t\t\tself.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);\r\n\r\n\t\t\t\t\t\t// How much velocity is required to start the deceleration\r\n\t\t\t\t\t\tvar minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1;\r\n\r\n\t\t\t\t\t\t// Verify that we have enough velocity to start deceleration\r\n\t\t\t\t\t\tif (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {\r\n\r\n\t\t\t\t\t\t\t// Deactivate pull-to-refresh when decelerating\r\n\t\t\t\t\t\t\tif (!self.__refreshActive) {\r\n\t\t\t\t\t\t\t\tself.__startDeceleration(timeStamp);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tself.options.scrollingComplete();\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((timeStamp - self.__lastTouchMove) > 100) {\r\n\t\t\t\t\tself.options.scrollingComplete();\r\n\t \t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If this was a slower move it is per default non decelerated, but this\r\n\t\t\t// still means that we want snap back to the bounds which is done here.\r\n\t\t\t// This is placed outside the condition above to improve edge case stability\r\n\t\t\t// e.g. touchend fired without enabled dragging. This should normally do not\r\n\t\t\t// have modified the scroll positions or even showed the scrollbars though.\r\n\t\t\tif (!self.__isDecelerating) {\r\n\r\n\t\t\t\tif (self.__refreshActive && self.__refreshStart) {\r\n\r\n\t\t\t\t\t// Use publish instead of scrollTo to allow scrolling to out of boundary position\r\n\t\t\t\t\t// We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\r\n\t\t\t\t\tself.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);\r\n\r\n\t\t\t\t\tif (self.__refreshStart) {\r\n\t\t\t\t\t\tself.__refreshStart();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif (self.__interruptedAnimation || self.__isDragging) {\r\n\t\t\t\t\t\tself.options.scrollingComplete();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);\r\n\r\n\t\t\t\t\t// Directly signalize deactivation (nothing todo on refresh?)\r\n\t\t\t\t\tif (self.__refreshActive) {\r\n\r\n\t\t\t\t\t\tself.__refreshActive = false;\r\n\t\t\t\t\t\tif (self.__refreshDeactivate) {\r\n\t\t\t\t\t\t\tself.__refreshDeactivate();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Fully cleanup list\r\n\t\t\tself.__positions.length = 0;\r\n\r\n\t\t},\r\n\r\n\r\n\r\n\t\t/*\r\n\t\t---------------------------------------------------------------------------\r\n\t\t\tPRIVATE API\r\n\t\t---------------------------------------------------------------------------\r\n\t\t*/\r\n\r\n\t\t/**\r\n\t\t * Applies the scroll position to the content element\r\n\t\t *\r\n\t\t * @param left {Number} Left scroll position\r\n\t\t * @param top {Number} Top scroll position\r\n\t\t * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\r\n\t\t */\r\n\t\t__publish: function(left, top, zoom, animate) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\t// Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\r\n\t\t\tvar wasAnimating = self.__isAnimating;\r\n\t\t\tif (wasAnimating) {\r\n\t\t\t\tcore.effect.Animate.stop(wasAnimating);\r\n\t\t\t\tself.__isAnimating = false;\r\n\t\t\t}\r\n\r\n\t\t\tif (animate && self.options.animating) {\r\n\r\n\t\t\t\t// Keep scheduled positions for scrollBy/zoomBy functionality\r\n\t\t\t\tself.__scheduledLeft = left;\r\n\t\t\t\tself.__scheduledTop = top;\r\n\t\t\t\tself.__scheduledZoom = zoom;\r\n\r\n\t\t\t\tvar oldLeft = self.__scrollLeft;\r\n\t\t\t\tvar oldTop = self.__scrollTop;\r\n\t\t\t\tvar oldZoom = self.__zoomLevel;\r\n\r\n\t\t\t\tvar diffLeft = left - oldLeft;\r\n\t\t\t\tvar diffTop = top - oldTop;\r\n\t\t\t\tvar diffZoom = zoom - oldZoom;\r\n\r\n\t\t\t\tvar step = function(percent, now, render) {\r\n\r\n\t\t\t\t\tif (render) {\r\n\r\n\t\t\t\t\t\tself.__scrollLeft = oldLeft + (diffLeft * percent);\r\n\t\t\t\t\t\tself.__scrollTop = oldTop + (diffTop * percent);\r\n\t\t\t\t\t\tself.__zoomLevel = oldZoom + (diffZoom * percent);\r\n\r\n\t\t\t\t\t\t// Push values out\r\n\t\t\t\t\t\tif (self.__callback) {\r\n\t\t\t\t\t\t\tself.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tvar verify = function(id) {\r\n\t\t\t\t\treturn self.__isAnimating === id;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tvar completed = function(renderedFramesPerSecond, animationId, wasFinished) {\r\n\t\t\t\t\tif (animationId === self.__isAnimating) {\r\n\t\t\t\t\t\tself.__isAnimating = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (self.__didDecelerationComplete || wasFinished) {\r\n\t\t\t\t\t\tself.options.scrollingComplete();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (self.options.zooming) {\r\n\t\t\t\t\t\tself.__computeScrollMax();\r\n\t\t\t\t\t\tif(self.__zoomComplete) {\r\n\t\t\t\t\t\t\tself.__zoomComplete();\r\n\t\t\t\t\t\t\tself.__zoomComplete = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\r\n\t\t\t\tself.__isAnimating = core.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tself.__scheduledLeft = self.__scrollLeft = left;\r\n\t\t\t\tself.__scheduledTop = self.__scrollTop = top;\r\n\t\t\t\tself.__scheduledZoom = self.__zoomLevel = zoom;\r\n\r\n\t\t\t\t// Push values out\r\n\t\t\t\tif (self.__callback) {\r\n\t\t\t\t\tself.__callback(left, top, zoom);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Fix max scroll ranges\r\n\t\t\t\tif (self.options.zooming) {\r\n\t\t\t\t\tself.__computeScrollMax();\r\n\t\t\t\t\tif(self.__zoomComplete) {\r\n\t\t\t\t\t\tself.__zoomComplete();\r\n\t\t\t\t\t\tself.__zoomComplete = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Recomputes scroll minimum values based on client dimensions and content dimensions.\r\n\t\t */\r\n\t\t__computeScrollMax: function(zoomLevel) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tif (zoomLevel == null) {\r\n\t\t\t\tzoomLevel = self.__zoomLevel;\r\n\t\t\t}\r\n\r\n\t\t\tself.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);\r\n\t\t\tself.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);\r\n\r\n\t\t},\r\n\r\n\r\n\r\n\t\t/*\r\n\t\t---------------------------------------------------------------------------\r\n\t\t\tANIMATION (DECELERATION) SUPPORT\r\n\t\t---------------------------------------------------------------------------\r\n\t\t*/\r\n\r\n\t\t/**\r\n\t\t * Called when a touch sequence end and the speed of the finger was high enough\r\n\t\t * to switch into deceleration mode.\r\n\t\t */\r\n\t\t__startDeceleration: function(timeStamp) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tif (self.options.paging) {\r\n\r\n\t\t\t\tvar scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);\r\n\t\t\t\tvar scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);\r\n\t\t\t\tvar clientWidth = self.__clientWidth;\r\n\t\t\t\tvar clientHeight = self.__clientHeight;\r\n\r\n\t\t\t\t// We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\r\n\t\t\t\t// Each page should have exactly the size of the client area.\r\n\t\t\t\tself.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;\r\n\t\t\t\tself.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;\r\n\t\t\t\tself.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;\r\n\t\t\t\tself.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tself.__minDecelerationScrollLeft = 0;\r\n\t\t\t\tself.__minDecelerationScrollTop = 0;\r\n\t\t\t\tself.__maxDecelerationScrollLeft = self.__maxScrollLeft;\r\n\t\t\t\tself.__maxDecelerationScrollTop = self.__maxScrollTop;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Wrap class method\r\n\t\t\tvar step = function(percent, now, render) {\r\n\t\t\t\tself.__stepThroughDeceleration(render);\r\n\t\t\t};\r\n\r\n\t\t\t// How much velocity is required to keep the deceleration running\r\n\t\t\tvar minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1;\r\n\r\n\t\t\t// Detect whether it's still worth to continue animating steps\r\n\t\t\t// If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\r\n\t\t\tvar verify = function() {\r\n\t\t\t\tvar shouldContinue = Math.abs(self.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\r\n\t\t\t\tif (!shouldContinue) {\r\n\t\t\t\t\tself.__didDecelerationComplete = true;\r\n\t\t\t\t}\r\n\t\t\t\treturn shouldContinue;\r\n\t\t\t};\r\n\r\n\t\t\tvar completed = function(renderedFramesPerSecond, animationId, wasFinished) {\r\n\t\t\t\tself.__isDecelerating = false;\r\n\t\t\t\tif (self.__didDecelerationComplete) {\r\n\t\t\t\t\tself.options.scrollingComplete();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\r\n\t\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\r\n\t\t\t};\r\n\r\n\t\t\t// Start animation and switch on flag\r\n\t\t\tself.__isDecelerating = core.effect.Animate.start(step, verify, completed);\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Called on every step of the animation\r\n\t\t *\r\n\t\t * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\r\n\t\t */\r\n\t\t__stepThroughDeceleration: function(render) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\r\n\t\t\t//\r\n\t\t\t// COMPUTE NEXT SCROLL POSITION\r\n\t\t\t//\r\n\r\n\t\t\t// Add deceleration to scroll position\r\n\t\t\tvar scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\r\n\t\t\tvar scrollTop = self.__scrollTop + self.__decelerationVelocityY;\r\n\r\n\r\n\t\t\t//\r\n\t\t\t// HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\r\n\t\t\t//\r\n\r\n\t\t\tif (!self.options.bouncing) {\r\n\r\n\t\t\t\tvar scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);\r\n\t\t\t\tif (scrollLeftFixed !== scrollLeft) {\r\n\t\t\t\t\tscrollLeft = scrollLeftFixed;\r\n\t\t\t\t\tself.__decelerationVelocityX = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);\r\n\t\t\t\tif (scrollTopFixed !== scrollTop) {\r\n\t\t\t\t\tscrollTop = scrollTopFixed;\r\n\t\t\t\t\tself.__decelerationVelocityY = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t//\r\n\t\t\t// UPDATE SCROLL POSITION\r\n\t\t\t//\r\n\r\n\t\t\tif (render) {\r\n\r\n\t\t\t\tself.__publish(scrollLeft, scrollTop, self.__zoomLevel);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tself.__scrollLeft = scrollLeft;\r\n\t\t\t\tself.__scrollTop = scrollTop;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t//\r\n\t\t\t// SLOW DOWN\r\n\t\t\t//\r\n\r\n\t\t\t// Slow down velocity on every iteration\r\n\t\t\tif (!self.options.paging) {\r\n\r\n\t\t\t\t// This is the factor applied to every iteration of the animation\r\n\t\t\t\t// to slow down the process. This should emulate natural behavior where\r\n\t\t\t\t// objects slow down when the initiator of the movement is removed\r\n\t\t\t\tvar frictionFactor = self.options.decelerationRate;\r\n\r\n\t\t\t\tself.__decelerationVelocityX *= frictionFactor;\r\n\t\t\t\tself.__decelerationVelocityY *= frictionFactor;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t//\r\n\t\t\t// BOUNCING SUPPORT\r\n\t\t\t//\r\n\r\n\t\t\tif (self.options.bouncing) {\r\n\r\n\t\t\t\tvar scrollOutsideX = 0;\r\n\t\t\t\tvar scrollOutsideY = 0;\r\n\r\n\t\t\t\t// This configures the amount of change applied to deceleration/acceleration when reaching boundaries\r\n\t\t\t\tvar penetrationDeceleration = self.options.penetrationDeceleration; \r\n\t\t\t\tvar penetrationAcceleration = self.options.penetrationAcceleration; \r\n\r\n\t\t\t\t// Check limits\r\n\t\t\t\tif (scrollLeft < self.__minDecelerationScrollLeft) {\r\n\t\t\t\t\tscrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\r\n\t\t\t\t} else if (scrollLeft > self.__maxDecelerationScrollLeft) {\r\n\t\t\t\t\tscrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (scrollTop < self.__minDecelerationScrollTop) {\r\n\t\t\t\t\tscrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\r\n\t\t\t\t} else if (scrollTop > self.__maxDecelerationScrollTop) {\r\n\t\t\t\t\tscrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Slow down until slow enough, then flip back to snap position\r\n\t\t\t\tif (scrollOutsideX !== 0) {\r\n\t\t\t\t\tif (scrollOutsideX * self.__decelerationVelocityX <= 0) {\r\n\t\t\t\t\t\tself.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tself.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (scrollOutsideY !== 0) {\r\n\t\t\t\t\tif (scrollOutsideY * self.__decelerationVelocityY <= 0) {\r\n\t\t\t\t\t\tself.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tself.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Copy over members to prototype\r\n\tfor (var key in members) {\r\n\t\tScroller.prototype[key] = members[key];\r\n\t}\r\n\r\n\tmodule.exports = Scroller;\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}