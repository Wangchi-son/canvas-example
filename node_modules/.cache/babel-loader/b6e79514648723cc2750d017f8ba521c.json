{"ast":null,"code":"/*\r\n * Scroller\r\n * http://github.com/zynga/scroller\r\n *\r\n * Copyright 2011, Zynga Inc.\r\n * Licensed under the MIT License.\r\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\r\n *\r\n * Based on the work of: Unify Project (unify-project.org)\r\n * http://unify-project.org\r\n * Copyright 2011, Deutsche Telekom AG\r\n * License: MIT + Apache (V2)\r\n */\n\n/**\r\n * Generic animation class with support for dropped frames both optional easing and duration.\r\n *\r\n * Optional duration is useful when the lifetime is defined by another condition than time\r\n * e.g. speed of an animating object, etc.\r\n *\r\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\r\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\r\n * based on the pure time difference.\r\n */\n(function (global) {\n  var time = Date.now || function () {\n    return +new Date();\n  };\n\n  var desiredFrames = 60;\n  var millisecondsPerSecond = 1000;\n  var running = {};\n  var counter = 1; // Create namespaces\n\n  var core = {\n    effect: {}\n  };\n  core.effect.Animate = {\n    /**\r\n     * A requestAnimationFrame wrapper / polyfill.\r\n     *\r\n     * @param callback {Function} The callback to be invoked before the next repaint.\r\n     * @param root {HTMLElement} The root element for the repaint\r\n     */\n    requestAnimationFrame: function () {\n      // Check for request animation Frame support\n      var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;\n      var isNative = !!requestFrame;\n\n      if (requestFrame && !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(requestFrame.toString())) {\n        isNative = false;\n      }\n\n      if (isNative) {\n        return function (callback, root) {\n          requestFrame(callback, root);\n        };\n      }\n\n      var TARGET_FPS = 60;\n      var requests = {};\n      var requestCount = 0;\n      var rafHandle = 1;\n      var intervalHandle = null;\n      var lastActive = +new Date();\n      return function (callback, root) {\n        var callbackHandle = rafHandle++; // Store callback\n\n        requests[callbackHandle] = callback;\n        requestCount++; // Create timeout at first request\n\n        if (intervalHandle === null) {\n          intervalHandle = setInterval(function () {\n            var time = +new Date();\n            var currentRequests = requests; // Reset data structure before executing callbacks\n\n            requests = {};\n            requestCount = 0;\n\n            for (var key in currentRequests) {\n              if (currentRequests.hasOwnProperty(key)) {\n                currentRequests[key](time);\n                lastActive = time;\n              }\n            } // Disable the timeout when nothing happens for a certain\n            // period of time\n\n\n            if (time - lastActive > 2500) {\n              clearInterval(intervalHandle);\n              intervalHandle = null;\n            }\n          }, 1000 / TARGET_FPS);\n        }\n\n        return callbackHandle;\n      };\n    }(),\n\n    /**\r\n     * Stops the given animation.\r\n     *\r\n     * @param id {Integer} Unique animation ID\r\n     * @return {Boolean} Whether the animation was stopped (aka, was running before)\r\n     */\n    stop: function (id) {\n      var cleared = running[id] != null;\n\n      if (cleared) {\n        running[id] = null;\n      }\n\n      return cleared;\n    },\n\n    /**\r\n     * Whether the given animation is still running.\r\n     *\r\n     * @param id {Integer} Unique animation ID\r\n     * @return {Boolean} Whether the animation is still running\r\n     */\n    isRunning: function (id) {\n      return running[id] != null;\n    },\n\n    /**\r\n     * Start the animation.\r\n     *\r\n     * @param stepCallback {Function} Pointer to function which is executed on every step.\r\n     *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\r\n     * @param verifyCallback {Function} Executed before every animation step.\r\n     *   Signature of the method should be `function() { return continueWithAnimation; }`\r\n     * @param completedCallback {Function}\r\n     *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\r\n     * @param duration {Integer} Milliseconds to run the animation\r\n     * @param easingMethod {Function} Pointer to easing function\r\n     *   Signature of the method should be `function(percent) { return modifiedValue; }`\r\n     * @param root {Element ? document.body} Render root, when available. Used for internal\r\n     *   usage of requestAnimationFrame.\r\n     * @return {Integer} Identifier of animation. Can be used to stop it any time.\r\n     */\n    start: function (stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {\n      var start = time();\n      var lastFrame = start;\n      var percent = 0;\n      var dropCounter = 0;\n      var id = counter++;\n\n      if (!root) {\n        root = document.body;\n      } // Compacting running db automatically every few new animations\n\n\n      if (id % 20 === 0) {\n        var newRunning = {};\n\n        for (var usedId in running) {\n          newRunning[usedId] = true;\n        }\n\n        running = newRunning;\n      } // This is the internal step method which is called every few milliseconds\n\n\n      var step = function (virtual) {\n        // Normalize virtual value\n        var render = virtual !== true; // Get current time\n\n        var now = time(); // Verification is executed before next animation step\n\n        if (!running[id] || verifyCallback && !verifyCallback(id)) {\n          running[id] = null;\n          completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, false);\n          return;\n        } // For the current rendering to apply let's update omitted steps in memory.\n        // This is important to bring internal state variables up-to-date with progress in time.\n\n\n        if (render) {\n          var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;\n\n          for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n            step(true);\n            dropCounter++;\n          }\n        } // Compute percent value\n\n\n        if (duration) {\n          percent = (now - start) / duration;\n\n          if (percent > 1) {\n            percent = 1;\n          }\n        } // Execute step callback, then...\n\n\n        var value = easingMethod ? easingMethod(percent) : percent;\n\n        if ((stepCallback(value, now, render) === false || percent === 1) && render) {\n          running[id] = null;\n          completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, percent === 1 || duration == null);\n        } else if (render) {\n          lastFrame = now;\n          core.effect.Animate.requestAnimationFrame(step, root);\n        }\n      }; // Mark as running\n\n\n      running[id] = true; // Init first step\n\n      core.effect.Animate.requestAnimationFrame(step, root); // Return unique animation ID\n\n      return id;\n    }\n  };\n  module.exports = core;\n})(typeof window !== 'undefined' ? window : this);","map":{"version":3,"sources":["C:/Users/sonwonjae/react/react-tutorial/canvas-example/node_modules/scroller/src/Animate.js"],"names":["global","time","Date","now","desiredFrames","millisecondsPerSecond","running","counter","core","effect","Animate","requestAnimationFrame","requestFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","isNative","test","toString","callback","root","TARGET_FPS","requests","requestCount","rafHandle","intervalHandle","lastActive","callbackHandle","setInterval","currentRequests","key","hasOwnProperty","clearInterval","stop","id","cleared","isRunning","start","stepCallback","verifyCallback","completedCallback","duration","easingMethod","lastFrame","percent","dropCounter","document","body","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","value","module","exports","window"],"mappings":"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","sourcesContent":["/*\r\n * Scroller\r\n * http://github.com/zynga/scroller\r\n *\r\n * Copyright 2011, Zynga Inc.\r\n * Licensed under the MIT License.\r\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\r\n *\r\n * Based on the work of: Unify Project (unify-project.org)\r\n * http://unify-project.org\r\n * Copyright 2011, Deutsche Telekom AG\r\n * License: MIT + Apache (V2)\r\n */\r\n\r\n/**\r\n * Generic animation class with support for dropped frames both optional easing and duration.\r\n *\r\n * Optional duration is useful when the lifetime is defined by another condition than time\r\n * e.g. speed of an animating object, etc.\r\n *\r\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\r\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\r\n * based on the pure time difference.\r\n */\r\n(function(global) {\r\n\tvar time = Date.now || function() {\r\n\t\treturn +new Date();\r\n\t};\r\n\tvar desiredFrames = 60;\r\n\tvar millisecondsPerSecond = 1000;\r\n\tvar running = {};\r\n\tvar counter = 1;\r\n\r\n\t// Create namespaces\r\n\tvar core = {\r\n\t\teffect: {}\r\n\t};\r\n\r\n\tcore.effect.Animate = {\r\n\r\n\t\t/**\r\n\t\t * A requestAnimationFrame wrapper / polyfill.\r\n\t\t *\r\n\t\t * @param callback {Function} The callback to be invoked before the next repaint.\r\n\t\t * @param root {HTMLElement} The root element for the repaint\r\n\t\t */\r\n\t\trequestAnimationFrame: (function() {\r\n\r\n\t\t\t// Check for request animation Frame support\r\n\t\t\tvar requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;\r\n\t\t\tvar isNative = !!requestFrame;\r\n\r\n\t\t\tif (requestFrame && !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(requestFrame.toString())) {\r\n\t\t\t\tisNative = false;\r\n\t\t\t}\r\n\r\n\t\t\tif (isNative) {\r\n\t\t\t\treturn function(callback, root) {\r\n\t\t\t\t\trequestFrame(callback, root)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tvar TARGET_FPS = 60;\r\n\t\t\tvar requests = {};\r\n\t\t\tvar requestCount = 0;\r\n\t\t\tvar rafHandle = 1;\r\n\t\t\tvar intervalHandle = null;\r\n\t\t\tvar lastActive = +new Date();\r\n\r\n\t\t\treturn function(callback, root) {\r\n\t\t\t\tvar callbackHandle = rafHandle++;\r\n\r\n\t\t\t\t// Store callback\r\n\t\t\t\trequests[callbackHandle] = callback;\r\n\t\t\t\trequestCount++;\r\n\r\n\t\t\t\t// Create timeout at first request\r\n\t\t\t\tif (intervalHandle === null) {\r\n\r\n\t\t\t\t\tintervalHandle = setInterval(function() {\r\n\r\n\t\t\t\t\t\tvar time = +new Date();\r\n\t\t\t\t\t\tvar currentRequests = requests;\r\n\r\n\t\t\t\t\t\t// Reset data structure before executing callbacks\r\n\t\t\t\t\t\trequests = {};\r\n\t\t\t\t\t\trequestCount = 0;\r\n\r\n\t\t\t\t\t\tfor(var key in currentRequests) {\r\n\t\t\t\t\t\t\tif (currentRequests.hasOwnProperty(key)) {\r\n\t\t\t\t\t\t\t\tcurrentRequests[key](time);\r\n\t\t\t\t\t\t\t\tlastActive = time;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Disable the timeout when nothing happens for a certain\r\n\t\t\t\t\t\t// period of time\r\n\t\t\t\t\t\tif (time - lastActive > 2500) {\r\n\t\t\t\t\t\t\tclearInterval(intervalHandle);\r\n\t\t\t\t\t\t\tintervalHandle = null;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}, 1000 / TARGET_FPS);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn callbackHandle;\r\n\t\t\t};\r\n\r\n\t\t})(),\r\n\r\n\r\n\t\t/**\r\n\t\t * Stops the given animation.\r\n\t\t *\r\n\t\t * @param id {Integer} Unique animation ID\r\n\t\t * @return {Boolean} Whether the animation was stopped (aka, was running before)\r\n\t\t */\r\n\t\tstop: function(id) {\r\n\t\t\tvar cleared = running[id] != null;\r\n\t\t\tif (cleared) {\r\n\t\t\t\trunning[id] = null;\r\n\t\t\t}\r\n\r\n\t\t\treturn cleared;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Whether the given animation is still running.\r\n\t\t *\r\n\t\t * @param id {Integer} Unique animation ID\r\n\t\t * @return {Boolean} Whether the animation is still running\r\n\t\t */\r\n\t\tisRunning: function(id) {\r\n\t\t\treturn running[id] != null;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * Start the animation.\r\n\t\t *\r\n\t\t * @param stepCallback {Function} Pointer to function which is executed on every step.\r\n\t\t *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\r\n\t\t * @param verifyCallback {Function} Executed before every animation step.\r\n\t\t *   Signature of the method should be `function() { return continueWithAnimation; }`\r\n\t\t * @param completedCallback {Function}\r\n\t\t *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\r\n\t\t * @param duration {Integer} Milliseconds to run the animation\r\n\t\t * @param easingMethod {Function} Pointer to easing function\r\n\t\t *   Signature of the method should be `function(percent) { return modifiedValue; }`\r\n\t\t * @param root {Element ? document.body} Render root, when available. Used for internal\r\n\t\t *   usage of requestAnimationFrame.\r\n\t\t * @return {Integer} Identifier of animation. Can be used to stop it any time.\r\n\t\t */\r\n\t\tstart: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {\r\n\r\n\t\t\tvar start = time();\r\n\t\t\tvar lastFrame = start;\r\n\t\t\tvar percent = 0;\r\n\t\t\tvar dropCounter = 0;\r\n\t\t\tvar id = counter++;\r\n\r\n\t\t\tif (!root) {\r\n\t\t\t\troot = document.body;\r\n\t\t\t}\r\n\r\n\t\t\t// Compacting running db automatically every few new animations\r\n\t\t\tif (id % 20 === 0) {\r\n\t\t\t\tvar newRunning = {};\r\n\t\t\t\tfor (var usedId in running) {\r\n\t\t\t\t\tnewRunning[usedId] = true;\r\n\t\t\t\t}\r\n\t\t\t\trunning = newRunning;\r\n\t\t\t}\r\n\r\n\t\t\t// This is the internal step method which is called every few milliseconds\r\n\t\t\tvar step = function(virtual) {\r\n\r\n\t\t\t\t// Normalize virtual value\r\n\t\t\t\tvar render = virtual !== true;\r\n\r\n\t\t\t\t// Get current time\r\n\t\t\t\tvar now = time();\r\n\r\n\t\t\t\t// Verification is executed before next animation step\r\n\t\t\t\tif (!running[id] || (verifyCallback && !verifyCallback(id))) {\r\n\r\n\t\t\t\t\trunning[id] = null;\r\n\t\t\t\t\tcompletedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// For the current rendering to apply let's update omitted steps in memory.\r\n\t\t\t\t// This is important to bring internal state variables up-to-date with progress in time.\r\n\t\t\t\tif (render) {\r\n\r\n\t\t\t\t\tvar droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;\r\n\t\t\t\t\tfor (var j = 0; j < Math.min(droppedFrames, 4); j++) {\r\n\t\t\t\t\t\tstep(true);\r\n\t\t\t\t\t\tdropCounter++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Compute percent value\r\n\t\t\t\tif (duration) {\r\n\t\t\t\t\tpercent = (now - start) / duration;\r\n\t\t\t\t\tif (percent > 1) {\r\n\t\t\t\t\t\tpercent = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Execute step callback, then...\r\n\t\t\t\tvar value = easingMethod ? easingMethod(percent) : percent;\r\n\t\t\t\tif ((stepCallback(value, now, render) === false || percent === 1) && render) {\r\n\t\t\t\t\trunning[id] = null;\r\n\t\t\t\t\tcompletedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);\r\n\t\t\t\t} else if (render) {\r\n\t\t\t\t\tlastFrame = now;\r\n\t\t\t\t\tcore.effect.Animate.requestAnimationFrame(step, root);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Mark as running\r\n\t\t\trunning[id] = true;\r\n\r\n\t\t\t// Init first step\r\n\t\t\tcore.effect.Animate.requestAnimationFrame(step, root);\r\n\r\n\t\t\t// Return unique animation ID\r\n\t\t\treturn id;\r\n\t\t}\r\n\t};\r\n\r\n\tmodule.exports = core;\r\n\r\n})(typeof window !== 'undefined' ? window : this);\r\n\r\n"]},"metadata":{},"sourceType":"script"}